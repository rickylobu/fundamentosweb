<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>3 JavaScript</title>
	<link rel="stylesheet" href="styles.css">

	<!-- explicar junto con Cargar pre code class="code-js" -->
	<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />

</head>

<body>
	<header id="header-javascript"><!-- Cabecera -->
		<nav>
			<figure>
				<a href="index.html"><img alt="logo de JavaScript" title="JavaScript" src="assets/img/javascript.png"
						width="100px" /></a>
				<figcaption>Logo de JavaScript</figcaption>
			</figure>
			<section>
				<h1>Curso de desarrollo de aplicaciones Web</h1>
				<ol>
					<li style="margin-left: 30px"><a href="index.html">Inicio</a></li>  
                    <li style="margin-left: 30px"><a href="mihtml.html">HTML5</a></li>
					<li><a href="css.html">CSS3</a></li>
					<li><a href="javascript.html">JavaScript</a></li>
					<li><a href="playground.html" target="_blank">Playground</a></li>
				</ol>
			</section>
		</nav>
	</header>
	<div id="container">
		<button class="menu-button" aria-label="Abrir menú">☰</button>
        <aside id="sidebar">
            <button class="close-menu" aria-label="Cerrar menú">✖</button>
        			<ol>
				<li><a href="#articleJavaScript">Artículo JavaScript</a></li>
				<li><a href="#añadir-JavaScript-a-HTML">Añadir JavaScript a HTML</a></li>
				<li><a href="#var-let-const">Variables var, let y const</a></li>
				<li><a href="#tipos-primitivos">Tipos de variables primitivos</a></li>
				<li><a href="#ejemplo-operadores">Ejemplo Operadores</a></li>
				<li><a href="#ejemplo-estructuras-control">Ejemplo estructuras de control</a></li>
				<li><a href="#ejemplo-funciones">Funciones en JavaScript</a></li>
				<li><a href="#this">Uso de this</a></li>
				<li><a href="#closure">Closure</a></li>
				<li><a href="#poo">Programación Orientada a Objetos en JavaScript</a></li>
				<li><a href="#ejemplo-poo">Ejemplo POO en javaScript</a></li>
				<li><a href="#arrays">Arrays en JavaScript</a></li>
				<li><a href="#programacion-funcional">Programación Funcional</a></li>
				<li><a href="#metodos-arrays-orden-superior">Métodos de Orden Superior de Arrays</a></li>
				<li><a href="#manipulacion-dom">Manipulación del DOM</a></li>
				<li><a href="#addEventListener">addEventListener</a></li>
				<li><a href="#addEventListener-ejemplos">Eventos principales con addEventListener</a></li>
				<li><a href="#addEventListener-avanzado">addEventListener Avanzado</a></li>
				<li><a href="#casos-Eventos-en-fase-propagacion">Casos de Uso en la Fase de Captura y Burbujeo</a></li>
				<li><a href="#asincronismo-en-JavaScript">Asincronismo en JavaScript</a></li>
				<li><a href="#fundamentos-asincronismo">Fundamentos de Asincronismo en JavaScript</a></li>
				<li><a href="#http">HTTP</a></li>
				<li><a href="#xhr">XMLHttpRequest (XHR) (Año: 1999)</a></li>
				<li><a href="#AJAX">AJAX</a></li>
				<li><a href="#json">JSON</a></li>
				<li><a href="#ejemplos-xhr">Ejemplos (XHR) con jsonplaceholder</a></li>
				<li><a href="#explicacion-promesas">Promesas "Promise" (Año: 2015)</a></li>
				<li><a href="#fetch-api">Fetch API (2015)</a></li>
				<li><a href="#explicacion-async-await">Async/Await "async/await" (2017)</a></li>
				<li><a href="#async-await-fetch">Ejemplo Async/Await con fetch</a></li>
				<li><a href="#top-level-await">Top-Level Await (2022)</a></li>
				<li><a href="#ejemplo-asincronismo-completo">Ejemplo Completo de Asincronismo en JavaScript</a></li>
				<li><a href="#testing">Testing en el Desarrollo de Software</a></li>
				<li><a href="#instalacion-nvm-npm-node-js">Guía para Instalar NVM y Node.js</a></li>
				<li><a href="#entendiendoPackage.json">Entendiendo un poco Package.json</a></li>
				<li><a href="#jest">Pruebas unitarias: Ejemplo de configuración con Jest</a></li>
				<li><a href="#jasmine">Pruebas unitarias: Ejemplo de configuración con Jasmine</a></li>
				<li><a href="#ejemplo-prueba-unitaria">Ejemplo completo de prueba unitaria con Jasmine</a></li>

			</ol>
		</aside>
		<main id="content">
			<section id="Clase-5-javascript-1">
				<figure>
					<iframe width="560" height="315" src="https://www.youtube.com/embed/VFm0UjqlAts?si=Si4WrXBefo0ZF-gy"
						title="Clase 5 JavaScript 1 parte 1/2 Sintaxis Básica y Funciones." frameborder="0"
						allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
						referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
					<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 5 JavaScript 1 parte 1/2 Sintaxis Básica y Funciones<a
							href="https://www.youtube.com/embed/VFm0UjqlAts?si=Si4WrXBefo0ZF-gy">@rickylobu en
							YouTube</a></figcaption>
				</figure>
			</section>
			<section id="articleJavaScript">
				<article>
					<header>
						<h2>JavaScript: Historia y Evolución</h2>
						<p>
						<address>Escrito por: <a href="correo_del_autor@ejemplo.com" target="_blank">Ricardo López
								Arriaga Bueno</a></address>
						<time datetime="2024-12-12">12 de Diciembre de 2024</time>
						</p>
					</header>

					<main>
						<blockquote cite="https://developer.mozilla.org/es/docs/Web/JavaScript">
							<p>
								<q>JavaScript es un lenguaje de programación que permite implementar funcionalidades
									complejas en páginas web, desde contenido dinámico hasta interacción con el
									usuario.</q>
								<cite>
									<a href="https://developer.mozilla.org/es/docs/Web/JavaScript" target="_blank">MDN
										Web Docs</a>
								</cite>
							</p>
						</blockquote>

						<h3>Nacimiento de JavaScript</h3>
						<blockquote cite="https://developer.mozilla.org/es/docs/Web/JavaScript">
							<p>
								<q>En 1995, Brendan Eich creó JavaScript en solo 10 días mientras trabajaba en Netscape,
									con el objetivo de desarrollar un lenguaje de scripting fácil de usar tanto para
									diseñadores como para programadores.</q>
								<cite>
									<a href="https://developer.mozilla.org/es/docs/Web/JavaScript" target="_blank">MDN
										Web Docs</a>
								</cite>
							</p>
						</blockquote>

						<h3>La Guerra de los Navegadores</h3>
						<blockquote cite="https://es.wikipedia.org/wiki/Historia_de_JavaScript">
							<p>
								<q>En los años 90, la competencia entre Netscape y Microsoft llevó a la fragmentación de
									JavaScript debido a diferentes implementaciones en los navegadores.</q>
								<cite>
									<a href="https://es.wikipedia.org/wiki/Historia_de_JavaScript"
										target="_blank">Wikipedia</a>
								</cite>
							</p>
						</blockquote>

						<h3>Estándar ECMAScript</h3>
						<blockquote cite="https://www.ecma-international.org/">
							<p>
								<q>En 1997, JavaScript fue estandarizado como ECMAScript por ECMA International,
									estableciendo un marco para su desarrollo futuro.</q>
								<cite>
									<a href="https://www.ecma-international.org/" target="_blank">ECMA International</a>
								</cite>
							</p>
						</blockquote>

						<h3>Evolución del Lenguaje</h3>
						<ul>
							<li><strong>ECMAScript 3 (1999):</strong> Mejoras en cadenas y expresiones regulares.</li>
							<li><strong>ECMAScript 5 (2009):</strong> Introducción del modo estricto y nuevos métodos de
								array.</li>
							<li><strong>ECMAScript 6 (2015):</strong><mark> let/const, Clases, módulos, promesas, y
									arrow functions</mark></li>
							<li><strong>ECMAScript 2016 (ES7):</strong> Introdujo el operador de exponenciación y el
								método Array.prototype.includes.</li>
							<li><strong>ECMAScript 2017 (ES8):</strong> Añadió async/await y mejoras en la manipulación
								de objetos.</li>
							<li><strong>ECMAScript 2018 (ES9):</strong> Introdujo rest/spread properties y mejoras en
								las expresiones regulares.</li>
							<li><strong>ECMAScript 2019 (ES10):</strong> Añadió flat/flatMap para arrays y mejoras en el
								manejo de errores.</li>
							<li><strong>ECMAScript 2020 (ES11):</strong> Introdujo el operador de encadenamiento
								opcional y nullish coalescing.</li>
							<li><strong>ECMAScript 2021 (ES12):</strong> Añadió métodos como replaceAll y mejoras en las
								promesas.</li>
							<li><strong>ECMAScript 2022 (ES13):</strong> Introdujo top-level await y mejoras en las
								clases.</li>
							<li><strong>ECMAScript 2023 (ES14):</strong> Añadió mejoras en los módulos y nuevas
								funciones de array.</li>
						</ul>

						<h3>El estándar actual</h3>
						<blockquote cite="https://developer.mozilla.org/es/docs/Web/JavaScript">
							<p>
								<q>
									JavaScript (JS) es un lenguaje de programación ligero, interpretado, o compilado
									justo-a-tiempo (just-in-time) con funciones de primera clase. Si bien es más
									conocido como un lenguaje de scripting (secuencias de comandos) para páginas web, y
									es usado en muchos entornos fuera del navegador como Node.js, JavaScript es un
									lenguaje de programación basada en prototipos,
									multiparadigma, de un solo hilo, dinámico, con soporte para programación orientada a
									objetos, imperativa y declarativa (por ejemplo programación funcional).
								</q>
								<cite>
									<a href="https://developer.mozilla.org/es/docs/Web/JavaScript" target="_blank">MDN
										Web Docs</a>
								</cite>
							</p>
						</blockquote>

						<blockquote
							cite="https://drive.google.com/file/d/1KHXX3Wx6k_sDk9loS1Dg05Ez3uwbc58U/view?usp=sharing">
							<p>
								<q>En la actualidad, la web funciona con HTML5, CSS3, y ECMAScript, que se renueva
									anualmente, siendo la versión actual ECMAScript 2024. Angular está actualmente en
									Angular 18, utiliza TypeScript en su versión 5.4 y transpila por defecto a
									ECMAScript
									2020.</q>
							</p>
							<p><q>Los sitios web pueden ser estáticos, dinámicos, plataformas, ERP (Enterprise
									Resource
									Planning), y demás términos para referirse a plataformas de gestión de recursos
									empresariales como recursos humanos, financieros, de gestión de proyectos, etc.
									También pueden ser aplicaciones web que funcionan con múltiples servidores en la
									nube
									que trabajan dando soporte a tu aplicación en todo el mundo (CDN). Con Node.js,
									lanzado en 2009, podemos usar JavaScript tanto en el frontend como en el backend, lo
									que permite aplicaciones isomórficas. Node.js ha abierto el camino para la creación
									de
									APIs que se ejecutan en el servidor, respondiendo a solicitudes que pueden dar
									solución
									por sí mismas o trabajar en conjunto con múltiples servicios que incluso pueden
									estar en
									distintos lenguajes dentro de contenedores como Docker o Kubernetes, comunicados
									entre sí
									mediante
									el protocolo HTTP, enviando y recibiendo JSON. Cada servicio los procesa en su
									propio
									lenguaje, que puede ser JavaScript, Java, PHP, Python, C++, C#, etc.
									(microservicios).<br>
									También pueden consultar otras APIs externas dentro de sus mismos procesos. Estos
									servidores CDN dan respuesta por medio de nuestra API (backend) a solicitudes de los
									clientes (frontend).</q></p>
							<p><q>La respuesta es enviada a aplicaciones web en el navegador, en desktop, o en
									aplicaciones móviles de múltiples sistemas operativos. El desarrollador web en la
									actualidad utiliza frameworks como Angular, React y Vue.js, que son escritos en
									TypeScript y transpilados a JavaScript para que puedan ser interpretados por el
									navegador o PWA mediante Ionic o desktop mediante Electron. Si su aplicación
									requiere
									de usar funciones nativas del dispositivo móvil para algo fundamental o si requiere
									de un
									mejor rendimiento, deberá hacer otro cliente (frontend) para la versión de Android
									con
									Kotlin o en Swift para iOS (multiplataforma).</q></p>
							<p><q>Por último mencionar que, el término “Full Stack” se refiere al desarrollador que
									domina
									tanto la parte del frontend como el backend. Sin embargo, el stack de tecnologías,
									lenguajes y frameworks puede ser muy diverso. Le recomiendo investigar sobre el
									“roadmap” del stack conforme a la decisión de especialización con la que quiera
									continuar sus estudios.</q></p>
							<cite>
								<a href="https://drive.google.com/file/d/1KHXX3Wx6k_sDk9loS1Dg05Ez3uwbc58U/view?usp=sharing"
									target="_blank">Historia y fundamentos de la Web</a>
							</cite>
							</p>
						</blockquote>
					</main>
				</article>
			</section>
			<hr class="non-js">
			<section id="añadir-JavaScript-a-HTML">
				<h2>Añadir JavaScript a HTML</h2>
				<p><strong><em>Existen tres formas principales de añadir JavaScript a un documento HTML</em></strong>:
					directamente en línea dentro de un atributo HTML como <code class="code-js"
						title="Código JavaScript">onclick</code>, dentro de etiquetas <code class="code-js"
						title="Código JavaScript">&lt;script&gt;</code> en el documento HTML antes de cerrar la etiqueta
					&lt;/body&gt;, o vinculando un archivo
					externo .js usando la etiqueta <code class="code-html"
						title="Código HTML5">&lt;script src="archivo.js"&gt;</code> de igual forma antes de cerrar la
					etiqueta &lt;/body&gt;.</p>
				<ul>
					<li>
						<strong>Con un atributo de evento inline:</strong>
						<p>Este método permite ejecutar JavaScript directamente dentro de un atributo de evento de un
							elemento HTML.</p>
						<pre><code class="code-html" title="Código JavaScript">&lt;button <span style="color: #EACA32">onclick="alert('Hola Mundo!');</span>"&gt;Haz clic aquí&lt;/button&gt;</code></pre>
					</li>
					<li>
						<strong>Con la etiqueta <code class="code-js"
								title="Código JavaScript">&lt;script&gt;</code>:</strong>
						<p>Este método permite escribir código JavaScript directamente en el documento HTML.</p>
						<pre><code class="code-html" title="Código JavaScript">
&lt;body&gt;
&lt;!-- cuerpo del body--&gt;
	&lt;button onclick="mostrarMensaje()"&gt;Mostrar Mensaje&lt;/button&gt;
	.
	.
	.
	&lt;!-- Antes de cerrar el body--&gt;
<span style="color: #EACA32">
	&lt;script&gt;
		function mostrarMensaje() {
			alert('Este mensaje proviene de una función en un script inline.');
		}
	&lt;/script&gt;
	</span>
&lt;/body&gt;
	</code></pre>
					</li>
					<li>
						<strong>Con un archivo JavaScript externo:</strong>
						<p>Este método permite mantener el código JavaScript separado del HTML, lo que mejora la
							organización y el mantenimiento del proyecto.</p>
						<pre><code class="code-html" title="Código HTML5">
	&lt;script src="script.js"&gt;&lt;/script&gt;
		</code></pre>
						<p>Crea un archivo llamado <em>script.js</em> con el siguiente contenido:</p>
						<pre><code class="code-js" title="Código JavaScript">
// Contenido de script.js
function saludar() {
	alert('Hola desde un archivo JavaScript externo.');
}
	</code></pre>
						<p>Luego, puedes vincularlo al documento HTML para usar las funciones definidas en el archivo.
						</p>
					</li>
				</ul>
			</section>
			<hr class="par-js">
			<section id="var-let-const">
				<h2>Declaración de Variables: var, let y const</h2>
				<p>En JavaScript, existen tres formas principales de declarar variables:</p>
				<ul>
					<li>
						<strong>var:</strong> Se utilizaba ampliamente antes de ES6, pero presenta problemas de alcance
						y redeclaración. Es de alcance global o de función.
					</li>
					<li>
						<strong>let:</strong> Introducido en ES6, permite declarar variables con alcance de bloque y
						evita la redeclaración en el mismo ámbito.
					</li>
					<li>
						<strong>const:</strong> También introducido en ES6, se utiliza para declarar constantes, es
						decir, variables cuyo valor no puede cambiar. Su alcance también es de bloque.
					</li>
				</ul>
			</section>
			<hr class="non-js">
			<section id="tipos-primitivos">
				<h2>Tipos Primitivos en JavaScript</h2>
				<p>JavaScript cuenta con los siguientes tipos primitivos:</p>
				<ul>
					<li><strong>number:</strong> Representa tanto números enteros como de punto flotante.</li>
					<li><strong>string:</strong> Representa secuencias de caracteres, delimitadas por comillas simples,
						dobles o backticks.</li>
					<li><strong>boolean:</strong> Solo tiene dos valores posibles: true o false.</li>
					<li><strong>null:</strong> Representa la ausencia intencional de un valor.</li>
					<li><strong>undefined:</strong> Indica que una variable no ha sido asignada.</li>
					<li><strong>symbol:</strong> Introducido en ES6, representa un identificador único.</li>
					<li><strong>bigint:</strong> Introducido en ES11, permite representar números enteros muy grandes.
					</li>
				</ul>
				<section id="ejemplo-variables-primitivos">
					<h3>Ejemplo Variables tipos primitivos</h3>
					<pre class="pre-largo"><code class="code-js" id="code-variables-primitivos"></code></pre>
					<p>╭☞( ͡ ͡° ͜ ʖ ͡͡°)╭☞ Presiona F12 para ver la consola</p>
					<p>Verás sólo el primer "Aloha Curioso!..."<br>
						Si presionas el botón: Ejecutar verás cómo se ejecuta el código anterior &leftarrow;</p>
					<button id="btn-variables-primitivos">Ejecutar</button>
					<section>
						<h4>Comparación con Tipos de Datos Primitivos</h4>
						<div id="contenedor-codigo-igualdad">
							<div class="explicacion">
								<p><strong><code class="code-js">==</code> (igualdad débil):</strong> Compara dos
									valores
									después de convertirlos a un tipo común. Por ejemplo, 5 == '5' es true porque
									convierte
									la
									cadena '5' a número antes de comparar.</p>
								<p><strong><code class="code-js">===</code> (igualdad estricta):</strong> Compara dos
									valores
									sin realizar ninguna conversión de tipo. Por ejemplo, 5 === '5' es false porque uno
									es
									número y el otro es cadena.</p>
								<h4>Comparación con Tipos de Datos de Referencia (Objetos, Funciones, Arreglos)</h4>
								<p>== y ===: Ambos operadores comparan referencias, no los valores reales. Dos objetos
									son
									iguales solo si apuntan a la misma ubicación en memoria. Por ejemplo:</p>
							</div>
							<pre class="pre-largo"><code class="code-js">
let obj1 = { a: 1 };
let obj2 = { a: 1 };
console.log(obj1 == obj2); // false
console.log(obj1 === obj2); // false
let obj3 = obj1;
console.log(obj1 == obj3); // true
console.log(obj1 === obj3); // true
						</code></pre>
						</div>
					</section>
				</section>
			</section>
			<hr class="non-js">
			<section id="ejemplo-operadores">
				<h2>Ejemplo: Operadores en JavaScript</h2>
				<pre class="pre-largo"><code class="code-js" id="code-operadores"></code></pre>
				<p>╭☞( ͡ ͡° ͜ ʖ ͡͡°)╭☞ Presiona F12 para ver la consola</p>
				<p>Presiona el botón para ejecutar el archivo de operadores en JavaScript.</p>
				<label for="fecha-nacimiento">¿Cuál es tu fecha de nacimiento?:</label><br>
				<input type="date" id="fecha-nacimiento">
				<button id="btn-operadores">Ejecutar</button>
				<p id="resultado"></p>
			</section>
			<hr class="par-js">
			<section id="ejemplo-estructuras-control">
				<h2>Estructuras de Control en JavaScript</h2>

				<!-- Contenedor principal -->
				<div class="contenedor-codigo-resultado">

					<div class="explicacion">
						<div>
							<h3>Condicional: if</h3>
							<p>El condicional `if` permite ejecutar un bloque de código si una condición es verdadera.
							</p>
							<button onclick="ejecutarIf()">Ejecutar if</button>
						</div>
						<div>
							<h3>Condicional: else if</h3>
							<p>El condicional `else if` permite evaluar múltiples condiciones en un bloque de código.
							</p>
							<button onclick="ejecutarElseIf()">Ejecutar else if</button>
						</div>
						<div>
							<h3>Condicional: switch</h3>
							<p>El condicional `switch` permite evaluar una variable contra múltiples casos específicos.
							</p>
							<button onclick="ejecutarSwitch()">Ejecutar switch</button>
						</div>
						<div>
							<h3>Bucle: for</h3>
							<p>El bucle `for` se utiliza para iterar un bloque de código un número definido de veces.
							</p>
							<button onclick="ejecutarFor()">Ejecutar for</button>
						</div>
						<div>
							<h3>Bucle: while</h3>
							<p>El bucle `while` ejecuta un bloque de código mientras una condición sea verdadera.</p>
							<button onclick="ejecutarWhile()">Ejecutar while</button>
						</div>
						<div>
							<h3>Bucle: do while</h3>
							<p>El bucle `do while` ejecuta un bloque de código al menos una vez antes de verificar la
								condición.</p>
							<button onclick="ejecutarDoWhile()">Ejecutar do while</button>
						</div>
					</div>

					<!-- Contenedor vertical -->
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-estructuras-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-control" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo"
					id="pre-ancho100"><code class="code-js" id="code-EstructurasControl"></code></pre>
			</section>
			<hr class="non-js">
			<section id="ejemplo-funciones">
				<section id="Clase-6-JavaScript-1">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/VFm0UjqlAts?si=WjR6ULMPEOSoNgwP"
							title="Clase 6 JavaScript 1 parte 2/2 Funciones hasta POO." frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 6 JavaScript 1 parte 2/2 Funciones hasta POO<a
								href="https://www.youtube.com/embed/VFm0UjqlAts?si=WjR6ULMPEOSoNgwP">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<h2>Funciones en JavaScript</h2>

				<p>Las funciones en JavaScript son la razón por la que JavaScript es un lenguaje tán versatil
					y flexible, pueden ser creadas mediante la palabra reservada <code class="code-js">function</code>.
				</p>
				<p>En JavaScript, las funciones son objetos de primera clase. Esto significa que pueden ser asignadas
					a variables, pasadas como argumentos a otras funciones y devueltas por otras funciones.</p>
				<!-- Contenedor principal -->
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<div>
							<h3>Función Global</h3>
							<p>Las funciones globales pueden ser llamadas desde cualquier lugar del documento.</p>
							<button onclick="ejecutarGlobal()">Ejecutar función global</button>
						</div>
						<div>
							<h3>Funciones Anónimas</h3>
							<p>Las funciones anónimas no tienen un nombre definido y pueden ser asignadas a variables o
								constantes.</p>
							<button onclick="ejecutarFuncionAnonima()">Ejecutar función anónima</button>
						</div>
						<div>
							<h3>Funciones asignadas a constantes</h3>
							<p>Las funciones pueden asignarse a constantes para ser reutilizadas.</p>
							<button onclick="ejecutarAsignadasAConstantes()">Ejecutar función asignada a
								constante</button>
						</div>
						<div>
							<h3>Funciones flecha</h3>
							<p>Las funciones flecha ofrecen una sintaxis más corta y no vinculan su propio <code
									class="code-js">this</code>.</p>
							<button onclick="ejecutarFuncionFlecha()">Ejecutar función flecha</button>
						</div>
						<div>
							<h3>Funciones como parámetros</h3>
							<p>En JavaScript, las funciones pueden pasarse como argumentos a otras funciones.</p>
							<button onclick="ejecutarFuncionComoParametro()">Ejecutar función como parámetro</button>
						</div>
						<div>
							<h3>Funciones como métodos de objetos</h3>
							<p>En JavaScript, las funciones pueden formar parte de objetos como métodos.</p>
							<button onclick="ejecutarMetodoObjeto()">Ejecutar función como método de objeto</button>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-funciones-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-funciones" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-Funciones"></code></pre>
			</section>
			<hr class="par-js">
			<section id="this">
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<h2>Uso de <code class="code-js">this</code></h2>
						<p>El contexto de <code class="code-js">this</code> puede variar dependiendo de cómo se
							llame una función y el ámbito donde es se utiliza <code class="code-js">this</code>.</p>
						<p>En funciones anidadas, es común usar una variable para almacenar el valor de this del
							contexto exterior o utilizar funciones flecha para heredar el this del contexto en el
							que fueron definidas.</p>
						<h3>Contexto Global</h3>
						<p>En el contexto global, <code class="code-js">this</code> se refiere al objeto global
							(window en navegadores).</p>
						<p>╭☞( ͡ ͡° ͜ ʖ ͡͡°)╭☞ Presiona F12 para ver la consola, escribe <code
								class="code-js">this;</code> y
							preciona Enter</p>
						<h3>Contexto de Objeto</h3>
						<p>Dentro de un método de un objeto, this se refiere al objeto al que pertenece el método.
						</p>
						<p>Con ejemplos es más fácil entender, preciona el botón y análiza con atención los
							siguientes ejemplos:</p>
						<button onclick="ejecutarThis()">Ejecutar uso de <code class="code-js">this</code></button>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-this-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-this" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-this"></code></pre>
			</section>
			<hr class="non-js">
			<section id="closure">
				<h2>Closure</h2>
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<p>Un <strong>closure</strong> es una función que recuerda el ámbito (scope) en el
							que fue creada, incluso después de que ese ámbito haya terminado. Esto significa
							que una función puede acceder a variables de su ámbito exterior, incluso después
							de que la función exterior haya terminado de ejecutarse.<br>
							Contexto Léxico: Es el contexto en el que una función fue creada. Un closure
							"recuerda" este contexto léxico.</p>
						<p><strong>Ámbito (Scope):</strong> Es el contexto en el que las variables y
							funciones son accesibles. En JavaScript, hay tres tipos principales de ámbitos:
						</p>
						<ul>
							<li>Global: Variables accesibles en cualquier parte del código.</li>
							<li>Local: Variables accesibles solo dentro de una función.</li>
							<li>Bloque: Variables accesibles solo dentro de un bloque de código (por
								ejemplo, dentro de un if o for).</li>
						</ul>
						<h3>Cronómetro</h3>
						<div>
							<h4>Controles del Cronómetro</h4>
							<button onclick="iniciarIncremento()">Iniciar Incremento</button>
							<button onclick="detener()">Detener</button>
							<button onclick="iniciarDecremento()">Iniciar Decremento</button>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-cronometro-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-cronometro" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-Closure"></code></pre>
			</section>
			<hr class="par-js">
			<section id="poo">
				<h2>Programación Orientada a Objetos en JavaScript</h2>
				<p>JavaScript no es orientado a objetos como tal, sino que usa un sistema llamado prototipos
					(<code class="code-js">prototype</code>).
				</p>
				<p>Los prototipos son como una especie de moldes. Cuando creas un objeto en JavaScript, este
					hereda propiedades y métodos de otro objeto llamado prototipo. Es decir, el objeto "hijo"
					comparte características del objeto "padre". </p>
				<p>Imagina que estás construyendo una casa. En lenguajes puramente orientados a objetos como
					Java, sería como tener un plano detallado (la clase) que usas para construir cada casa (los
					objetos). En JavaScript, es más como copiar una casa existente (el prototipo) y hacer
					algunos cambios para crear una nueva (el objeto).</p>
				<p>La ventaja es que puedes modificar el prototipo original y todos los objetos que se basaron
					en él también cambian. <strong>como actualizar el plano original y que todas las casas
						nuevas
						tengan los cambios incluidos.</strong></p>
				<p>Cuando utilizas la sintaxis de <code class="code-js">class</code> y <code
						class="code-js">extends</code> en JavaScript, por debajo el motor del
					lenguaje lo traduce y ejecuta utilizando <code class="code-js">prototype</code>.
					Es decir, aunque escribas código como si estuvieras usando clases, JavaScript internamente
					está trabajando con prototipos y la herencia prototípica.<br>
					Esto significa que la forma en que defines tus "clases" y la herencia con extends se
					convierte en operaciones sobre prototipos. La sintaxis de class y extends es simplemente una
					forma más legible y amigable para los desarrolladores que vienen de lenguajes orientados a
					objetos basados en clases, pero la esencia de JavaScript sigue siendo la herencia
					prototípica.</p>

				<!-- Métodos de POO -->
				<div class="contenedor-codigo-resultado">
					<!-- Métodos para explicar conceptos de POO -->
					<div class="explicacion">
						<p><strong>Clases:</strong> Plantillas para crear objetos. Definen propiedades y métodos.</p>
						<button onclick="ejecutarClases()">Ejecutar Clases</button>
						<p><strong>Objetos:</strong> Instancias de clases. Contienen datos y comportamientos.</p>
						<button onclick="ejecutarObjetos()">Ejecutar Objetos</button>
						<p><strong>Herencia:</strong> Permite que una clase herede propiedades y métodos de otra clase
							debido al <strong>encadenamiento de prototipos</strong>, los prototipos pueden heredar de
							otros
							prototipos, creando una cadena de prototipos. Cuando accedes a una propiedad o método de un
							objeto, JavaScript busca en la cadena de prototipos hasta encontrarlo.</p>
						<p>Es importante recordar que para poder Agregar una herencia a un prototypo del lenguaje
							javascript
							como <code class="code-js">Array.prototype.CustomMethod = function (miArray) {};</code>/p>
							se utiliza <strong>function</strong> para crear su propio <code class="code-js">this</code>.
						</p>
						<button onclick="ejecutarHerencia()">Ejecutar Herencia</button>
						<p><strong>Encapsulamiento:</strong> Oculta los detalles internos de un objeto y expone solo lo
							necesario.</p>
						<p>En JavaScript, no existe una palabra clave private como en otros lenguajes totalmente
							orientados a objetos.</p>
						<p>Con ECMAScript 2020, se introdujeron los campos privados de clase utilizando el símbolo <code
								class="code-js">#</code>.</p>
						<button onclick="ejecutarEncapsulamiento()">Ejecutar Encapsulamiento</button>
						<p><strong>Polimorfismo:</strong> Permite que diferentes clases utilicen el mismo método de
							diferentes maneras.</p>
						<p>El polimorfismo es la capacidad de un objeto de tomar muchas formas. En JavaScript, esto se
							logra a través de la herencia prototípica y la capacidad de <mark><strong>sobrescribir
									métodos en la cadena de prototipos.</strong></mark></p>
						<p>Imagina que tienes un prototipo llamado "Animal" con un método "hacerSonido()". Luego, creas
							dos prototipos "hijos" llamados "Perro" y "Gato", ambos heredando de "Animal". Cada uno de
							estos prototipos "hijos" puede <strong>sobrescribir el método</strong> "hacerSonido()" para
							que haga un sonido diferente (por ejemplo, "Guau" para "Perro" y "Miau" para "Gato").</p>
						<p>Ahora, puedes tener un array de objetos, algunos "Perros" y algunos "Gatos". Cuando llamas
							al método "hacerSonido()" en cada objeto, se ejecutará la versión correcta del método según
							el prototipo del objeto (ya sea "Guau" o "Miau"). Esto es polimorfismo: el mismo método
							("hacerSonido()") se comporta de manera diferente según el tipo de objeto.</p>
						<button onclick="ejecutarPolimorfismo()">Ejecutar Polimorfismo</button>
						<p><strong>Abstracción:</strong> Simplifica la complejidad ocultando los detalles innecesarios y
							mostrando solo la funcionalidad esencial.</p>
						<p>En JavaScript, no existen las palabras reservadas abstract e interface como en otros
							lenguajes de programación orientada a objetos (POO). Aunque JavaScript no tiene soporte
							nativo para clases abstractas e interfaces, se pueden simular mediante patrones de diseño y
							convenciones. Las clases abstractas se pueden crear lanzando errores en el constructor si se
							intenta instanciarlas directamente, y las interfaces se pueden definir mediante objetos que
							especifican métodos que deben ser implementados.</p>
						<button onclick="ejecutarAbstraccion()">Ejecutar Abstracción</button>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-poo-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-poo" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-poo"></code></pre>
			</section>
			<section id="ejemplo-poo">
				<h3>Ejemplo de Clases y Objetos</h3>
				<!-- Ejemplo de POO -->
				<div class="contenedor-codigo-resultado">
					<!-- Métodos para explicar Ejemplo de POO en JavaScript -->
					<div class="explicacion">
						<p>Imagina que debes crear un sistema de Vehiculos y necesitas crear objetos de tipo Coche pero
							también Motos donde estos objetos hereden de Vehiculo e implementen multiples interfaces que
							obliguen a que arranquen y frenen de forma diferente entre motos y coches y el Coche que
							implemente una interfaz que
							haga un carro convertible cosa que las motos no hacen</p>
						<p>Ahora que sabes los conceptos básicos de Programación Orientada a Objetos (POO) te recomiendo
							que terminando esta clase te des el tiempo de investigar y sobre todo practicar POO con
							principios SOLID. </p>
						<p>Otra tarea iteresante que te recomiendo es investigar sobre el patrón de diseño creacional
							<strong>Factory</strong> y comenzar a profundizar en patrones de diseño en general. <br>Un
							excelente punto de partida es saber que existen múltiples tipos de patrones de diseño como
							creacionales, estructurales y de comportamiento.
						</p>
						<button onclick="ejecutarEjemploPOO()">Ejecutar Ejemplo</button>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-ejemplo-poo-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-ejemplo-poo" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-ejemplo-poo"></code></pre>
			</section>
			<hr class="non-js">
			<section id="arrays">
				<section id="Clase-7-JavaScript-2.">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/gHia1IR5Wtw?si=37-Ks8IcKqwpIDow"
							title="Clase 7 JavaScript 2 Arrays, P. Funcional y Métodos de orden Superior de Arrays" frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 7 JavaScript 2 Arrays, P. Funcional y Métodos de orden Superior de Arrays<a
								href="https://www.youtube.com/embed/gHia1IR5Wtw?si=37-Ks8IcKqwpIDow">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<h2>Arrays en JavaScript</h2>
				<p>
					En JavaScript, un array es una estructura de datos utilizada para almacenar múltiples valores en una
					sola variable. Puedes declarar un array vacío y asignarlo a una variable utilizando
					<code class="code-js">const miArray = [];</code>. También es posible crear un array inicializado con
					valores de diferentes tipos de datos:
					<code class="code-js">const miArray = [42, "texto", true, null, undefined];</code>.
				</p>
				<p>
					Generalmente, los arreglos contienen elementos del mismo tipo o estructuras de objetos similares, ya
					que esto facilita aplicar lógica uniforme sobre ellos mediante bucles o métodos nativos del
					lenguaje.
					Por ejemplo, un array de objetos puede representar datos complejos como usuarios, productos o
					configuraciones personalizadas:
					<code
						class="code-js">const usuarios = [{nombre: "Juan", edad: 30}, {nombre: "Ana", edad: 25}];</code>.
				</p>
				<p>
					Los objetos dentro de un array pueden tener arreglos internos o estructuras más complejas. Por
					ejemplo, podrías modelar un sistema de pasajeros y un conductor para un coche o un autobús,
					lo que podría llevar a la construcción de un sistema más grande compuesto por múltiples objetos.
					Para construir sistemas así de complejos donde el constructor se hace enorme, te recomiendo
					investigar el patrón de diseño creacional <strong>Builder</strong> y explorar más patrones de diseño
					en general.
				</p>

				<!-- Métodos de Arrays -->
				<div class="contenedor-codigo-resultado">
					<!-- Métodos para agregar y eliminar elementos -->
					<div class="explicacion">
						<h3>Métodos para agregar y eliminar elementos</h3>
						<div>
							<h4>push()</h4>
							<p>Agrega uno o más elementos al final del array y devuelve la nueva longitud del array.</p>
							<input type="text" id="input-push" placeholder="Elemento a agregar">
							<button onclick="ejecutarArrayPush()">Ejecutar push()</button>
						</div>
						<div>
							<h4>pop()</h4>
							<p>Elimina el último elemento del array y lo devuelve.</p>
							<button onclick="ejecutarArrayPop()">Ejecutar pop()</button>
						</div>
						<div>
							<h4>unshift()</h4>
							<p>Agrega uno o más elementos al principio del array y devuelve la nueva longitud del array.
							</p>
							<input type="text" id="input-unshift" placeholder="Elemento a agregar">
							<button onclick="ejecutarArrayUnshift()">Ejecutar unshift()</button>
						</div>
						<div>
							<h4>shift()</h4>
							<p>Elimina el primer elemento del array y lo devuelve.</p>
							<button onclick="ejecutarArrayShift()">Ejecutar shift()</button>
						</div>
						<!-- Métodos para transformar y ordenar -->
						<h3>Métodos para transformar y ordenar</h3>
						<div>
							<h4>concat()</h4>
							<p>Combina dos o más arrays y devuelve un nuevo array resultante.</p>
							<button onclick="ejecutarArrayConcat()">Ejecutar concat()</button>
						</div>
						<div>
							<h4>sort()</h4>
							<p>Ordena los elementos del array alfabéticamente o según una función de comparación.</p>
							<button onclick="ejecutarArraySort()">Ejecutar sort()</button>
						</div>
						<div>
							<h4>slice()</h4>
							<p>Devuelve una copia superficial de una porción del array en un nuevo array.</p>
							<button onclick="ejecutarArraySlice()">Ejecutar slice()</button>
						</div>
						<div>
							<h4>reverse()</h4>
							<p>Invierte el orden de los elementos en el array.</p>
							<button onclick="ejecutarArrayReverse()">Ejecutar reverse()</button>
						</div>
						<div>
							<h4>flat()</h4>
							<p>Devuelve un nuevo array con todos los elementos de subarrays concatenados en un solo
								nivel.</p>
							<button onclick="ejecutarArrayFlat()">Ejecutar flat()</button>
						</div>
						<!-- Métodos para obtener información sobre el array-->
						<h3>Métodos para obtener información sobre el array</h3>

						<div>
							<h4>includes()</h4>
							<p>Comprueba si un elemento está presente en el array:
								<code class="code-js">const array = [1, 2, 3, 4,
								"Ricardo", "Willy", "Patricio",
								"Bob", "Alan", "Francisco"
							];</code>
							</p>
							<input type="text" id="input-includes" placeholder="Elemento a buscar">
							<button onclick="ejecutarArrayIncludes()">Ejecutar includes()</button>
						</div>
						<div>
							<h4>indexOf()</h4>
							<p>Devuelve el primer índice en el que se encuentra un elemento especificado, o -1 si no se
								encuentra.</p>
							<button onclick="ejecutarArrayIndexOf()">Ejecutar indexOf()</button>
						</div>
						<div>
							<h4>lastIndexOf()</h4>
							<p>Devuelve el último índice en el que se encuentra un elemento especificado, o -1 si no se
								encuentra.</p>
							<button onclick="ejecutarArrayLastIndexOf()">Ejecutar lastIndexOf()</button>
						</div>
						<div>
							<h4>length</h4>
							<p>Devuelve la cantidad de elementos en el array.</p>
							<button onclick="ejecutarArrayLength()">Obtener longitud</button>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-ejemplo-arrays-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-ejemplo-arrays" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-ejemplo-arrays"></code></pre>
			</section>
			<hr class="par-js">
			<section id="programacion-funcional">
				<h2>Programación funcional en JavaScript</h2>
				<h3>Historia de la Programación Funcional</h3>
				<p>
					La programación funcional tiene sus raíces en las matemáticas, específicamente en el cálculo lambda
					(&#955;), desarrollado por Alonzo Church en la década de 1930. Este sistema formal define las
					funciones como ciudadanos de primera clase y enfatiza la aplicación de funciones y la composición,
					en lugar de cambios en el estado o la mutabilidad.</p>
				<p>
					A medida que los lenguajes de programación han evolucionado, muchos han adoptado elementos
					funcionales. JavaScript, aunque originalmente no fue diseñado como un lenguaje puramente funcional,
					ha integrado conceptos clave, especialmente con la llegada de ES6.
				</p>
				<h3>Conceptos fundamentales:</h3>
				<p>
					<strong>Funciones de Primera Clase:</strong> Como vimos anteriormente las funciones son "ciudadanos
					de primera clase", lo que significa que pueden asignarse a variables, pasarse como argumentos y
					devolverse desde otras funciones. Observa con atención el siguiente ejemplo:<br>
				<pre><code class="code-js">
const saludo = () => "Hola Curioso!"; // asignamos una función anónima a variable 
const decirHola = saludo; // Asignar una función a otra variable
console.log(decirHola()); // ejecutamos la función decirHola() y el resultado se lo mandamos a .log. Salida: Hola Curioso!
console.log(decirHola); // 	mandamos la función decirHola a la función .log. Salida: () => "Hola, Mundo!" 
					</code></pre>
				</p>
				<p>
					<strong>Inmutabilidad:</strong> En programación funcional, los datos no se modifican. En su lugar,
					se crean nuevas versiones con los cambios necesarios. Esto evita efectos secundarios y hace que el
					código sea más predecible.
				</p>
				<pre><code class="code-js">
const array = [1, 2, 3];
const newArray = [...array, 4]; // Se crea un nuevo arreglo con spread operator (...)
console.log(array);  // [1, 2, 3]
console.log(newArray);  // [1, 2, 3, 4]
				</code></pre>
				<p>
					<strong>Transparencia Referencial:</strong> Una función es transparente si, dada la misma entrada,
					siempre produce la misma salida, sin efectos secundarios.
				</p>
				<pre><code class="code-js">
const suma = (a, b) => a + b;
console.log(suma(2, 3));  // Siempre devuelve: 5
console.log(suma("Hola", " Mundo"));  // Siempre devuelve: Hola Mundo
				</code></pre>

				<!-- Métodos de Conceptos Programación Funcional -->
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<h2>Programación Funcional en JavaScript</h2>
						<div>
							<h3>Funciones de Orden Superior</h3>
							<p>Una función de orden superior es aquella que toma una o más funciones como
								parámetros/argumentos, o devuelve una función. Por ejemplo:<br>
							<pre><code class="code-js">intervalo = setInterval(() => {
	tiempo++;
	console.log(tiempo);
}, 1000);
</code></pre>
							</p>
							<button onclick="ejecutarFnOrdenSuperior()"> Ejecutar Fn de Orden Superior()</button>
						</div>
						<div>
							<h3>Funciones Callbacks</h3>
							<p> Son funciones que se pasan como argumentos a otras funciones y se ejecutan
								posteriormente.</p>
							<p> Generalmente se utilizan funciones Callback cuando estamos trabajando con funciones
								asincronas como veremos más adelante.</p>
							<button onclick="ejecutarFnCallback()">Ejecutar Fn Callback()</button>
						</div>
						<div>
							<h3>Funciones Puras</h3>
							<p>Una función pura es aquella que no tiene efectos secundarios y siempre devuelve el mismo
								resultado para los mismos argumentos.</p>
							<p>En programación funcional, las funciones puras son aquellas que cumplen dos condiciones
								principales:</p>
							<ol>
								<li>Determinismo: Dadas las mismas entradas, siempre producen la misma salida. No
									dependen de ningún estado externo o variable global que pueda cambiar entre
									llamadas.</li>
								<li>Sin efectos secundarios: No modifican ningún estado externo ni producen efectos
									observables fuera de su propio ámbito. No alteran variables globales, objetos
									mutables ni realizan operaciones de entrada/salida.</li>
							</ol>

							<button onclick="ejecutarFnPura()">Ejecutar Fn Pura()</button>
						</div>
						<div>
							<h3>Composición de Funciones</h3>
							<p>Combinar funciones simples para crear funciones más complejas. <code
									class="code-js">(f, g) => x => f(g(x));</code></p>
							<button onclick="ejecutarFnComposicion()">Ejecutar Fn Composición()</button>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-programacion-funcional-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-programacion-funcional" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo"
					id="pre-ancho100"><code class="code-js" id="code-programacion-funcional"></code></pre>
			</section>
			<hr class="non-js">
			<section id="metodos-arrays-orden-superior">
				<!-- Métodos de Arrays de orden superior-->
				<h2>Métodos de Orden Superior de Arrays</h2>
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<div>
							<h3>forEach()</h3>
							<p>Ejecuta una función para cada elemento del array.</p>
							<p>Es una función de orden superior porque acepta otra función como argumento, pero no es
								una función pura. Esto se debe a que <code class="code-js">forEach()</code> se utiliza
								para provocar efectos secundarios (por ejemplo, modificar variables externas o imprimir
								en consola) y no devuelve un nuevo array.</p>
							<button onclick="ejecutarForEach()">Ejecutar forEach()</button>
						</div>
						<div>
							<h3>sort()</h3>
							<p>Ordena los elementos del mismo array según una función de comparación, modificando el
								array original. Por ello, aunque es de orden superior, no es pura ya que altera el
								estado del array.</p>
							<button onclick="ejecutarArraySortPF()">Ejecutar sort()</button>
						</div>
						<hr class="non-js">
						<h2>Funciones <strong>Puras</strong> de Orden Superior de Arrays</h2>
						<div>
							<h3><mark>map()</mark></h3>
							<p>
								Aplica la función callback a cada elemento del array y devuelve un nuevo array con los
								resultados.
								No modifica el array original, lo que la convierte en una función pura, respetando el
								principio de inmutabilidad y de transparencia referencial.
							</p>
							<button onclick="ejecutarArrayMap()">Ejecutar map()</button>
						</div>
						<div>
							<h3><mark>filter()</mark></h3>
							<p>
								Devuelve un nuevo array con todos los elementos que cumplen la condición especificada en
								la función callback.
								El array original permanece sin cambios, por lo que es una función pura.
							</p>
							<button onclick="ejecutarArrayFilter()">Ejecutar filter()</button>
						</div>
						<div>
							<h3><mark>reduce()</mark></h3>
							<p>
								Recorre el array y acumula sus elementos en un único valor mediante una función
								acumuladora,
								devuelto sin modificar el array original. Siempre que la función callback sea pura,
								<code class="code-js">reduce()</code> es una función pura.
							</p>
							<button onclick="ejecutarArrayReduce()">Ejecutar reduce()</button>
						</div>
						<div>
							<h3>some()</h3>
							<p>
								Comprueba si al menos un elemento del array cumple la condición definida en el callback.
								Devuelve un valor booleano sin modificar el array, por lo que es pura.
							</p>
							<button onclick="ejecutarArraySome()">Ejecutar some()</button>
						</div>
						<div>
							<h3>every()</h3>
							<p>
								Verifica si todos los elementos del array cumplen la condición especificada por el
								callback.
								Devuelve un valor booleano y no altera el array original, siendo así una función pura.
							</p>
							<button onclick="ejecutarArrayEvery()">Ejecutar every()</button>
						</div>
						<div>
							<h3>find()</h3>
							<p>
								Devuelve el primer elemento del array que cumpla la condición definida en el callback.
								No modifica el array original, por lo que es una función pura.
							</p>
							<button onclick="ejecutarArrayFind()">Ejecutar find()</button>
						</div>
						<div>
							<h3>findIndex()</h3>
							<p>
								Devuelve el índice del primer elemento que cumple la condición del callback o -1 si
								ninguno la cumple.
								Al no alterar el array original, es una función pura.
							</p>
							<button onclick="ejecutarArrayFindIndex()">Ejecutar findIndex()</button>
						</div>
						<div>
							<h3>flatMap()</h3>
							<p>
								Aplica una función a cada elemento del array y luego aplana el resultado un nivel en un
								nuevo array.
								No modifica el array original, lo que la hace pura y acorde con la inmutabilidad.
							</p>
							<button onclick="ejecutarArrayFlatMap()">Ejecutar flatMap()</button>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-metodos-arrays-orden-superior-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-metodos-arrays-orden-superior" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo"
					id="pre-ancho100"><code class="code-js" id="code-metodos-arrays-orden-superior"></code></pre>
				<hr>
				<section id="Recursividad-Explicacion-JavaScript">
					<h2>Recursividad y Composición de Funciones en Programación Funcional</h2>
					<p>La recursividad es una técnica en la que una función se llama a sí misma para resolver problemas
						que
						pueden dividirse en subproblemas más pequeños. En programación funcional, esta característica es
						muy
						valiosa para iterar sobre estructuras complejas, como arrays que contienen objetos anidados o
						arrays
						dentro de objetos. Gracias a la recursividad, es posible recorrer de manera concisa
						cualquier nivel de anidamiento. Además, la composición de funciones permite encadenar varias
						transformaciones de datos en un solo flujo de operaciones, respetando el principio de
						inmutabilidad.
						De este modo, cada función es pura (sin efectos secundarios) y devuelve un nuevo valor basado en
						su
						entrada, lo que facilita el razonamiento y la reutilización del código.</p>

					<p>Dado que en JavaScript se pueden procesar estructuras de datos complejas donde cada elemento
						puede
						ser un objeto con atributos y métodos, o incluso contener arrays anidados. Este enfoque se
						potencia
						cuando se combinan la recursividad y la composición de funciones, ya que permite transformar
						cada
						nivel de la estructura sin alterar los datos originales. Es importante tener presente que en
						JavaScript “todo es un prototipo”: los objetos, las funciones y los arrays son, a su vez,
						objetos
						que heredan de un prototipo. Esta característica es esencial para entender cómo se estructuran y
						manipulan los datos, ya que permite que cada objeto tenga sus propios métodos y atributos,
						facilitando la extensión y la reutilización de código a través de la cadena de prototipos.</p>
				</section>
			</section>
			<hr class="par-js">
			<section id="manipulacion-dom">
				<section id="Clase-8-JavaScript-3">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/iDvrbkp6mnQ?si=-EILmnwbqLwXOduL"
							title="Clase 8 JavaScript 3 parte 1/2 Manipulacion del DOM" frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 8 JavaScript 3 parte 1/2 Manipulacion del DOM<a
								href="https://www.youtube.com/embed/iDvrbkp6mnQ?si=-EILmnwbqLwXOduL">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<h2>Manipulación del DOM en JavaScript</h2>
				<p>Como ya sabemos JavaScript es el lenguaje que entiende el navegador y es un lenguaje que esta
					100% ligado a la Web, es por esto que es tán importante saber manipular el DOM (Document Object
					Model)
					formado por <strong>document</strong> vinculado a la etiqueta &lt;body&gt;, del cual se desprenden
					todos los elementos del contenido visible de la página Web cargada, generando el DOM, de esta forma
					podemos gestionar los eventos y su propagación por el DOM por medio del método <code
						class="code-js">addEventListener</code> como veremos en la siguiente sección.
				</p>
				<h2>El DOM y la Interpretación del HTML en el Navegador</h2>
				<p>Cuando se carga una página web, el navegador interpreta las etiquetas HTML (por ejemplo, las
					etiquetas
					&lt;html&gt;, &lt;body&gt;, &lt;div&gt;, etc.) y construye un árbol de nodos, conocido como el
					Document Object Model (DOM). Cada
					uno de estos nodos es un objeto que, al igual que cualquier otro objeto en JavaScript, se basa
					en un prototipo y dispone de propiedades y métodos. Esta estructura jerárquica permite
					identificar fácilmente relaciones de padre, hijo, hermano, etc. y es fundamental para la
					manipulación dinámica de la interfaz mediante JavaScript. La capacidad de recorrer y transformar
					estas estructuras mediante recursividad y composición de funciones de la programación funcional
					se vuelve muy poderosa a la hora de aplicar cambios, buscar elementos o actualizar información
					en el DOM sin alterar el estado global de la aplicación, entendiendo que al modificar elementos
					no se utilizan las funciones puras en la manipulación del DOM pero si en las transformaciones de
					los datos.</p>

				<h3>El Objeto Global y el Manejo de Eventos</h3>
				<p>El objeto global window es el contenedor de todo el entorno de ejecución en el navegador, y
					dentro de él se encuentra el objeto document, que representa el DOM. Dado que tanto arrays como
					funciones y objetos en JavaScript <strong>se basan en prototipos</strong>, tanto
					<strong>window</strong>, como <strong>document</strong>,
					como cada <strong>elemento</strong> del DOM son instancias de objetos de <code
						class="code-js">HTMLDivElement</code> o <code class="code-js">HTMLParagraphElement</code> etc.
					heredan
					de <code class="code-js">HTMLElement</code> que tiene el protipo Element.prototype que a su vez
					hereda
					de <code class="code-js">Node</code> que hereda de
					<code class="code-js">EventTarget</code> hasta <code class="code-js">Object</code>
				</p>
				<p>Dado que los objetos del DOM son, en esencia, objetos comunes (<code
						class="code-js">typeof Object</code> retorna "object"). Esto implica que heredan de <code
						class="code-js">Object.prototype</code> y, por lo tanto, tienen acceso a sus métodos y
					propiedades. Por ejemplo con <code class="code-js">Object.setPrototypeOf(obj, prototype);</code>
					podemos indicar que un tipo de prototipo cambie, lo cual no es muy recomendado pero con ello
					podemos
					lograr un polimorfismo dinámico donde podemos hacer que un Objeto que sobrecarga un método
					para que, en lugar de que se comporte diferente en cada tipo de instancia como en el
					polimorfismo normal, se comporte como uno de los otros tipos que
					implmentan de forma diferente el mismo método. Te invito a pensar un escenario donde esto sea
					necesario.
				</p>
				<p>
					Además, el manejo de eventos en la web, mediante métodos
					como <code class="code-js">addEventListener</code>, se apoya en el concepto de “burbujeo de eventos”
					(event bubbling), donde
					los eventos generados en un nodo se propagan a sus nodos padres. Lo que quiero que comprendas
					de esta sección es que el DOM y todos sus elementos son objetos basados en prototipos
					que se comportan como objetos, es decir que heredan propiedades y métodos a lo largo de
					la jerarquía, lo que resulta sumemente importante para la manipulación del DOM y la captura de
					eventos
					en aplicaciones web, por lo que vamos a profundizar en esto:
				</p>

				<h3>La Cadena de Prototipos en la API del DOM</h3>
				<p>Cuando hablamos de que un elemento del DOM es un objeto, nos referimos a que:</p>
				<ul>
					<li><strong>window:</strong> Es el objeto global en el navegador que contiene a document.</li>
					<li><strong>document:</strong> Es una propiedad de window que representa el documento HTML y es el
						punto de entrada al DOM. Esto significa que
						<code class="code-js">window.document</code> es una instancia de <code
							class="code-js">Document</code>
					</li>
					<li><strong>Nodos y Elementos:</strong> Cada elemento en el DOM es un objeto que forma parte de una
						jerarquía
						de prototipos. Por ejemplo, si tienes un &lt;div&gt;, este es una instancia de
						HTMLDivElement, que
						hereda de HTMLElement, que a su vez hereda de Element, luego de Node, EventTarget y
						finalmente de Object.
						<mark><strong>Esto significa que todos los métodos y propiedades comunes (como appendChild,
								removeChild, etc.) se definen en los prototipos y son accesibles a cada
								instancia.</strong></mark>
						Cuando seleccionas un elemento con <code class="code-js">document.getElementById</code>,
						simplemente
						recuperas la referencia al objeto que ya fue instanciado al renderizar la página.
						No se crea una nueva instancia; se utiliza la existente que forma parte de la estructura del
						DOM. Así, el DOM y el objeto <code class="code-js">window</code> junto con su respectivo
						objeto <code class="code-js">document</code> están profundamente
						integrados a través de la cadena de prototipos.</strong>
					</li>
				</ul>
				<p>Cuando utilizas un método como document.getElementById('miImagen'), el navegador devuelve la
					referencia a un objeto que ya fue creado durante el renderizado del HTML. Este objeto es, por
					ejemplo, una instancia de <code class="code-js">HTMLImageElement</code>.</p>
				<pre style="color: white;">
HTMLImageElement (o HTMLDivElement, etc.)
   └── HTMLElement
         └── Element
               └── Node
                     └── EventTarget
                           └── Object
</pre>
				<p>En este ejemplo, cada objeto hereda de su prototipo. Por ejemplo, si llamas a <code
						class="code-js">img.getAttribute('src')</code>, el método getAttribute se encuentra en el
					prototipo de <strong>Element</strong>. Esto es posible gracias a la cadena de herencia, lo que
					permite que todos los elementos tengan acceso a funcionalidades comunes sin necesidad de que cada
					uno defina sus propios métodos.</p>
				<p>Siguiendo con el ejemplo de seleccionar una imágen, este elemento tendría la siguiente herencia de
					prototipos simplificada comenzando por el elemento seleccionado y sus ancestros hasta Object:</p>
				<ol>
					<li>
						<h4>HTMLImageElement (o cualquier otro elemento específico como HTMLDivElement,
							HTMLParagraphElement,
							etc.)</h4>
					</li>
					<p><strong>Es la interfaz que representa elementos &lt;img&gt; en el DOM.</strong></p>
					<ul>
						<li><strong>Atributos y Propiedades Específicas:</strong></li>
						<ul>
							<li><strong>src:</strong> URL de la imagen.</li>
							<li><strong>alt:</strong> Texto alternativo.</li>
							<li><strong>height / width:</strong> Altura y anchura de la imagen.</li>
							<li><strong>naturalHeight / naturalWidth:</strong> Dimensiones originales de la imagen.</li>
							<li><strong>complete:</strong> Indica si la imagen ha terminado de cargarse.</li>
							<li><strong>crossOrigin, decoding, loading, etc.:</strong> Propiedades específicas para
								controlar el comportamiento de carga y la seguridad.</li>
						</ul>
						<li><strong>Métodos Especiales:</strong> No añade métodos propios adicionales a los heredados,
							pero
							su existencia como HTMLImageElement permite que el navegador trate las imágenes de manera
							optimizada.</li>
					</ul>
					<li>
						<h4>HTMLElement</h4>
					</li>
					<p><strong>Representa elementos HTML genéricos (como &lt;div&gt;, &lt;p&gt;, &lt;span&gt;, etc.). Es
							una
							extensión de Element y agrega funcionalidades específicas de la presentación y
							comportamiento en
							la web.</strong></p>
					<ul>
						<li><strong>Propiedades y Atributos Específicos:</strong></li>
						<ul>
							<li><strong>style:</strong> Objeto CSSStyleDeclaration para manipular estilos en línea.</li>
							<li><strong>title:</strong> Texto de información adicional.</li>
							<li><strong>accessKey:</strong> Permite definir una tecla de acceso rápido.</li>
							<li><strong>dataset:</strong> Permite acceder a atributos de datos (data-*).</li>
							<li><strong>contentEditable, dir, lang, hidden, tabIndex, etc.:</strong> Otros atributos que
								controlan la presentación y comportamiento del elemento.</li>
						</ul>
						<li><strong>Métodos Específicos:</strong> focus(), blur(), click(): Para interactuar con el
							elemento
							de manera programática.</li>
					</ul>
					<li>
						<h4>Element</h4>
					</li>
					<p><strong>Es la interfaz base para todos los elementos de HTML y XML en el DOM.</strong></p>
					<ul>
						<li><strong>Propiedades y Atributos Comunes:</strong></li>
						<ul>
							<li><strong>id:</strong> Identificador único del elemento.</li>
							<li><strong>className:</strong> La o las clases CSS asignadas.</li>
							<li><strong>tagName:</strong> Nombre de la etiqueta (por ejemplo, "DIV", "IMG").</li>
							<li><strong>innerHTML, outerHTML:</strong> Contenido HTML interno y externo.</li>
						</ul>
						<li><strong>Métodos Comunes:</strong> getAttribute(), setAttribute(), removeAttribute(): Para
							gestionar atributos. querySelector(), querySelectorAll(): Para buscar descendientes que
							coincidan con selectores CSS. closest(), matches(): Para buscar elementos relacionados en la
							jerarquía del DOM.</li>
					</ul>
					<li>
						<h4>Node</h4>
					</li>
					<p><strong>Es la interfaz base de la cual heredan todos los nodos en el DOM, incluidos elementos,
							nodos
							de texto y comentarios.</strong></p>
					<ul>
						<li><strong>Propiedades:</strong></li>
						<ul>
							<li><strong>nodeName, nodeType, nodeValue:</strong> Información básica sobre el nodo.</li>
							<li><strong>childNodes:</strong> Colección de nodos hijos (incluye nodos de texto).</li>
							<li><strong>firstChild, lastChild, nextSibling, previousSibling:</strong> Para navegar entre
								nodos (hay que tener en cuenta que estos pueden ser nodos de texto).</li>
							<li><strong>firstElementChild, lastElementChild, nextElementSibling,
									previousElementSibling:</strong> Versión filtrada que solo incluye elementos (sin
								nodos
								de texto).</li>
						</ul>
						<li><strong>Métodos:</strong> appendChild(), insertBefore(), removeChild(), replaceChild(),
							cloneNode(), normalize(), etc.: Para manipular la estructura del DOM.</li>
					</ul>
					<li>
						<h4>EventTarget</h4>
					</li>
					<p><strong>Es la interfaz que proporciona la capacidad de registrar y gestionar listeners de
							eventos.
							Prácticamente, todos los elementos del DOM (y el objeto document, window) son instancias de
							EventTarget.</strong></p>
					<ul>
						<li><strong>Métodos Clave:</strong> addEventListener(type, listener, [options]): Registra un
							listener para un evento. removeEventListener(type, listener, [options]): Remueve un
							listener.
							dispatchEvent(event): Despacha un evento, activando todos los listeners asociados.</li>
					</ul>
					<li>
						<h4>Object</h4>
					</li>
					<p><strong>La raíz de la cadena de prototipos en JavaScript. Todos los objetos, incluidos los del
							DOM,
							heredan de Object.prototype.</strong></p>
					<ul>
						<li><strong>Métodos Comunes:</strong> toString(), valueOf(), hasOwnProperty(), isPrototypeOf(),
							propertyIsEnumerable(), etc.: Métodos generales para todos los objetos.</li>
					</ul>
				</ol>
				<h3>Manipulación de Elementos del DOM</h3>
				<p>
					En JavaScript, el DOM (Document Object Model) es la representación estructural de la página web y
					permite interactuar de forma dinámica con los elementos HTML.
					Mediante métodos de selección, modificación y manipulación, podemos acceder y cambiar el contenido,
					atributos o estructura de los elementos.
				</p>
				<ul>
					<li><strong>Seleccionar elementos:</strong>
						<ul>
							<li><code class="code-js">document.getElementById</code></li>
							<li><code class="code-js">document.getElementsByTagName</code></li>
							<li><code class="code-js">document.getElementsByClassName</code></li>
							<li><code class="code-js">document.querySelector</code></li>
							<li><code class="code-js">document.querySelectorAll</code></li>
						</ul>
					</li>
					<li><strong>Modificar contenido y atributos:</strong>
						<ul>
							<li><code class="code-js">innerText</code></li>
							<li><code class="code-js">innerHTML</code></li>
							<li><code class="code-js">setAttribute</code>.</li>
						</ul>
					</li>
					<li><strong>Añadir y eliminar elementos:</strong>
						<ul>
							<li><code class="code-js">document.createElement</code></li>
							<li><code class="code-js">document.createTextNode</code></li>
							<li><code class="code-js">appendChild</code></li>
							<li><code class="code-js">removeChild</code>.</li>
						</ul>
					</li>
				</ul>


				<p>Veamos cada una en detalle para comprender con ejemplos:</p>
				<!-- Ejemplos de Manipulación del DOM-->
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<!-- SECCIÓN: Seleccionar elementos -->
						<div class="detalle-section">
							<h3>Seleccionar elementos</h3>
							<div class="detalle-metodo">
								<h4>document.getElementById</h4>
								<p>
									Este método devuelve el elemento del DOM cuyo id coincide con el proporcionado. Es
									ideal para acceder de forma directa a un único elemento.
								</p>
								<button onclick="ejecutarGetElementById()">Ejecutar getElementById()</button>
								<div class="container-resultado" id="container-getElementById"></div>
							</div>
							<div class="detalle-metodo">
								<h4>document.getElementsByTagName</h4>
								<p>
									Devuelve una colección de elementos que comparten la misma etiqueta HTML. Es útil
									para obtener todos los elementos de un tipo específico.
								</p>
								<button onclick="ejecutarGetElementsByTagName()">Ejecutar
									getElementsByTagName()</button>
								<div class="container-resultado" id="container-getElementsByTagName"></div>
							</div>
							<div class="detalle-metodo">
								<h4>document.getElementsByClassName</h4>
								<p>
									Retorna una colección de elementos que tienen la clase CSS especificada, permitiendo
									seleccionar múltiples elementos a la vez.
								</p>
								<button onclick="ejecutarGetElementsByClassName()">Ejecutar
									getElementsByClassName()</button>
								<div class="container-resultado" id="container-getElementsByClassName"></div>
							</div>
							<div class="detalle-metodo">
								<h4>document.querySelector</h4>
								<p>
									Permite seleccionar el primer elemento que coincide con el selector CSS dado,
									ofreciendo una sintaxis muy flexible.
								</p>
								<button onclick="ejecutarQuerySelector()">Ejecutar querySelector()</button>
								<div class="container-resultado" id="container-querySelector"></div>
							</div>
							<div class="detalle-metodo">
								<h4>document.querySelectorAll</h4>
								<p>
									Devuelve una NodeList de todos los elementos que coinciden con el selector CSS, lo
									que facilita iterar sobre ellos.
								</p>
								<button onclick="ejecutarQuerySelectorAll()">Ejecutar querySelectorAll()</button>
								<div class="container-resultado" id="container-querySelectorAll"></div>
							</div>
						</div>
						<!-- SECCIÓN: Modificar contenido y atributos -->
						<div class="detalle-section">
							<h3>Modificar contenido y atributos</h3>
							<div class="detalle-metodo">
								<h4>innerText / innerHTML</h4>
								<p>
									Estos atributos permiten modificar el contenido textual (innerText) o el contenido
									HTML (innerHTML) de un elemento. Con innerHTML puedes incluso insertar etiquetas
									HTML.
								</p>
								<button onclick="ejecutarModificarContenidoYatributos()">Ejecutar
									innerText/innerHTML</button>
								<div class="container-resultado" id="container-modificarContenido"></div>
							</div>
							<div class="detalle-metodo">
								<h4>setAttribute</h4>
								<p>
									Permite establecer o modificar un atributo de un elemento, lo que es útil para
									actualizar propiedades o agregar datos personalizados.
								</p>
								<button onclick="ejecutarSetAttribute()">Ejecutar setAttribute()</button>
								<div class="container-resultado" id="container-setAttribute"></div>
							</div>
						</div>
						<!-- SECCIÓN: Añadir y eliminar elementos -->
						<div class="detalle-section">
							<h3>Añadir y eliminar elementos</h3>
							<div class="detalle-metodo">
								<h4>document.createElement / document.createTextNode</h4>
								<p>
									Estos métodos se usan para crear nuevos nodos de elementos y nodos de texto,
									respectivamente. Son la base para generar contenido dinámico.
								</p>
								<button onclick="ejecutarCrearElementos()">Ejecutar
									createElement/createTextNode()</button>
								<div class="container-resultado" id="container-crearElementos"></div>
								<p><mark>Presionalo muchas veces! veras que se cambia el backgroundColor del primero y
										el ultimo y los demas permanecen en blanco porque se va restableciendo el
										color.</mark></p>
							</div>
							<div class="detalle-metodo">
								<h4>appendChild / removeChild</h4>
								<p>
									appendChild añade un nodo como hijo de un elemento, mientras que removeChild elimina
									un nodo hijo específico. Son esenciales para modificar la estructura del DOM.
								</p>
								<button onclick="ejecutarAppendRemoveChild()">Ejecutar
									appendChild/removeChild()</button>
								<div class="container-resultado" id="container-appendRemoveChild"></div>
								<p><mark>Presionalo muchas veces! tienes 5 segundos antes de que se borren el primero y
										el último elemento, pero se cambia el backgroundColor del primero y el ultimo y
										sus hermanos respectivamente.</mark></p>
							</div>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-manipulacion-DOM-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-manipulacion-DOM" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-manipulacion-DOM"></code></pre>

			</section>
			<hr class="non-js">
			<section id="addEventListener">
				<section id="Clase-9-JavaScript-3">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/F6CuuYq6B0g?si=1zAuw_rSU6Ahtqhx"
							title="Clase 9 JavaScript 3 parte 2/2 addEventListener" frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 9 JavaScript 3 parte 2/2 addEventListener<a
								href="https://www.youtube.com/embed/F6CuuYq6B0g?si=1zAuw_rSU6Ahtqhx">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<h2>Manejo de Eventos con <code class="code-js">addEventListener</code> en JavaScript</h2>
				<p>Esperando que ya esté completamente claro, todo objeto que sea un <em>EventTarget</em>
					(como nodos, elementos, document, window, etc.) tiene acceso a
					<code class="code-js">addEventListener</code> sin necesidad de redefinirlo.
				</p>
				<h3>Conceptos Básicos:</h3>
				<ul>
					<li><strong>Trigger (Desencadenante):</strong> Es la acción o estímulo que inicia un evento. Por
						ejemplo, un clic, el envío de un formulario o el movimiento del ratón son triggers que pueden
						generar eventos en el DOM.</li>
					<li><strong>Evento:</strong> Es la notificación de que el trigger ha ocurrido, generando un
						objeto <code class="code-js">Event</code> por addEventListener. Cada evento tiene propiedades
						específicas que describen
						qué sucedió y en qué elemento mediante <code class="code-js">type</code> y <code
							class="code-js">target</code>.</li>
					<li><strong>Listener/Handler:</strong> Función callback que se ejecuta en respuesta al evento.</li>
					<li><strong>EventListener (Oyente de Eventos):</strong> Mecanismo para registrar un listener en un
						elemento del DOM mediante la función addEventListener.</li>
				</ul>
				<p><code class="code-js">addEventListener</code> es un método de EventTarget que <strong>permite asociar
						un evento</strong>
					a partir de un trigger o desencadenante (como un clic, desplazamiento, envío de formulario, etc.)
					<strong>a un elemento específico</strong> del Document Object Model (DOM) <strong>asignandole una
						función
						"Callback".</strong><br>Qué en este contexto o paradigma es la función cuya responsabiidad es
					estar a la "escucha"
					(listener) y "controlar" o ejecutar la respuesta al evento que puede ser diversa (handler).<br>
					Es decir, este método escucha el evento y ejecuta una función especificada (listener/handler) cuando
					el evento ocurre.
				</p>
				<h3>Parámetros y Funcionamiento:</h3>
				<p>La firma del método es:</p>
				<pre><code class="code-js">	element.addEventListener(type, listener[, options]);</code></pre>
				<ul>
					<li><code class="code-js">type</code>: Cadena que representa el tipo de evento (ej. "click",
						"mouseover", "keydown").</li>
					<li><code class="code-js">listener</code>: Función callback que se ejecuta cuando ocurre el evento.
						Recibe un objeto <code class="code-js">Event</code>.</li>
					<li><code class="code-js">options</code>: Parámetro opcional que puede ser un <mark><strong>booleano
								que indica la fase en que se ejecutará</strong></mark>, o un objeto
						con propiedades avanzadas (<code class="code-js">capture</code>, <code
							class="code-js">once</code>, <code class="code-js">passive</code>, <code
							class="code-js">signal</code>).</li>
				</ul>

				<p><strong>Ejemplo Básico:</strong></p>
				<pre><code class="code-js">	elementoSeleccionadoDelDOM.addEventListener('click', (event) => {
			console.log('Se hizo clic en', event.target);
		});</code></pre>

				<h3>El Objeto <code class="code-js">Event</code>: Atributos y Métodos Clave</h3>
				<p>Cuando ocurre un evento, el navegador crea un objeto <code class="code-js">Event</code> que contiene
					información importante sobre el evento y es mandado como argumento a la función (listener/handler).
					Algunos de sus atributos y métodos más relevantes son:</p>
				<h4>Atributos:</h4>
				<ul>
					<li><code class="code-js">event.type</code>: Tipo de evento (por ejemplo, "click").</li>
					<li><code class="code-js">event.target</code>: Elemento que disparó el evento.</li>
					<li><code class="code-js">event.currentTarget</code>: Elemento al que se asignó el listener,
						útil para delegación de eventos.</li>
					<li><code class="code-js">event.eventPhase</code>: Indica la fase del evento (captura, target o
						burbujeo).</li>
					<li><code class="code-js">event.bubbles</code>: Booleano que indica si el evento se propaga en la
						fase de burbujeo.</li>
					<li><code class="code-js">event.cancelable</code>: Indica si se puede cancelar el comportamiento por
						defecto.</li>
					<li><code class="code-js">event.defaultPrevented</code>: Booleano que muestra si se ha llamado a
						preventDefault().</li>
					<li><code class="code-js">event.timeStamp</code>: El tiempo transcurrido desde que carga la página
						hasta que se creó el evento.</li>
				</ul>
				<h4>Métodos:</h4>
				<ul>
					<li><code class="code-js">preventDefault()</code>: Evita el comportamiento por defecto del evento.
					</li>
					<li><code class="code-js">stopPropagation()</code>: Detiene la propagación del evento a otros
						elementos en el DOM.</li>
					<li><code class="code-js">stopImmediatePropagation()</code>: Detiene la propagación del evento y
						evita que se ejecuten otros listeners en el mismo elemento.</li>
				</ul>
				<h3>Propagación de Eventos en el DOM:</h3>
				<p><mark><strong>Los eventos se propagan en tres fases:</strong></mark></p>
				<h4>Fase de Captura:</h4>
				<ul>
					<li>El evento se inicia en el objeto window y desciende por el árbol del DOM hasta el elemento
						objetivo.</li>
					<li>Los listeners registrados con capture: true se ejecutan en esta fase.</li>
					<li>Permite a los elementos ancestros interceptar el evento antes de que llegue al elemento que lo
						disparó.</li>
					<li><strong>Control de la Propagación</strong>: Puedes detener la propagación en cualquier fase
						utilizando
						stopPropagation() o stopImmediatePropagation() en el objeto Event.</li>
				</ul>
				<h4>Fase de Target:</h4>
				<p>El evento llega al elemento objetivo y se ejecutan los listeners registrados en ese elemento, sin
					importar si fueron configurados con capture o no.</p>
				<h4>Fase de Burbujeo:</h4>
				<ul>
					<li>El evento se propaga hacia arriba, desde el elemento objetivo hasta el objeto window.</li>
					<li>Los listeners registrados sin la opción capture (o con capture: false) se ejecutan durante esta
						fase.</li>
					<li><strong>Control de la Propagación</strong>: Puedes detener la propagación en cualquier fase
						utilizando
						stopPropagation() o stopImmediatePropagation() en el objeto Event.</li>
				</ul>
				<!-- Ejemplo de Delegación de Eventos -->
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<h3>Ejemplo de Propagación de eventos en el DOM:</h3>
						<p>Presta atención al siguiente ejemplo de listeners en fase de captura, target y burbujeo para
							comprender por completo la propagación de eventos en el DOM</p>
						<button onclick="ejecutarPropagacionEventos()">Ejecutar Propagación de Eventos</button>
						<div id='ejemplo-propagacion-eventos'></div>
						<hr>
						<h3>Ejemplo de Delegación de Eventos:</h3>
						<p>En lugar de asignar múltiples <code class="code-js">onclick</code> a cada elemento, se asigna
							un único listener a un contenedor padre para manejar los clics en sus elementos hijos.</p>
						<p> En este ejemplo usamos delegación de eventos para validar un formulario con tres campos:
							correo (con @ y .), contraseña (mayor a 6 caracterés)
							y edad (mayor a 18). En lugar de asignar un listener a cada campo o botón,
							asignamos un único listener al contenedor padre (en este caso, el propio formulario) que se
							encarga de manejar el evento de envío. Según la validación, se resalta el campo en error
							(con una clase CSS) y se muestra un mensaje error o de éxito.</p>
						<div id="form-container">
							<form id="registration-form" method="post">
								<div>
									<label for="email">Correo:</label>
									<input type="email" id="email" name="email" required>
								</div>
								<div>
									<label for="password">Contraseña:</label>
									<input type="password" id="password" name="password" required>
								</div>
								<div>
									<label for="age">Edad:</label>
									<input type="number" id="age" name="age" required>
								</div>
								<input type="submit" value="Enviar Formulario"></input>
							</form>
							<div id="result"></div>
						</div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-addEventListener-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-addEventListener" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-addEventListener"></code></pre>
			</section>
			<hr>
			<section id="addEventListener-ejemplos">
				<h2>Eventos principales con <code class="code-js">addEventListener</code> en JavaScript</h2>
				<p>Los eventos en JavaScript permiten responder a la interacción del usuario con la interfaz. A
					continuación se describen algunos de los eventos más comunes:</p>

				<!-- Ejemplos de Eventos de addEventListener -->
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<ol>
							<!-- CLICK -->
							<li>
								<h3>Click</h3>
							</li>
							<p>
								El evento <code class="code-js">click</code> se dispara cuando se hace clic en un
								elemento.
							</p>
							<button onclick="ejecutarClick()">Ejecutar Click</button>
							<div id="container-ejemplo-click"></div>

							<!-- DBLCLICK -->
							<li>
								<h3>Doble Click (dblclick)</h3>
							</li>
							<p>
								El evento <code class="code-js">dblclick</code> se dispara cuando se hace doble clic
								en un elemento.
							</p>
							<button onclick="ejecutarDblClick()">Ejecutar Doble Click</button>
							<div id="container-ejemplo-dblclick"></div>

							<!-- MOUSEOVER -->
							<li>
								<h3>Mouse Over</h3>
							</li>
							<p>
								El evento <code class="code-js">mouseover</code> se dispara cuando el puntero del
								ratón se mueve
								sobre un elemento.
							</p>
							<button onclick="ejecutarMouseOver()">Ejecutar Mouse Over</button>
							<div id="container-ejemplo-mouseover"></div>

							<!-- MOUSEOUT -->
							<li>
								<h3>Mouse Out</h3>
							</li>
							<p>
								El evento <code class="code-js">mouseout</code> se dispara cuando el puntero del
								ratón se mueve
								fuera de un elemento.
							</p>
							<button onclick="ejecutarMouseOut()">Ejecutar Mouse Out</button>
							<div id="container-ejemplo-mouseout"></div>

							<!-- MOUSEDOWN -->
							<li>
								<h3>Mouse Down</h3>
							</li>
							<p>
								El evento <code class="code-js">mousedown</code> se dispara cuando se presiona un
								botón del ratón
								sobre un elemento.
							</p>
							<button onclick="ejecutarMouseDown()">Ejecutar Mouse Down</button>
							<div id="container-ejemplo-mousedown"></div>

							<!-- MOUSEUP -->
							<li>
								<h3>Mouse Up</h3>
							</li>
							<p>
								El evento <code class="code-js">mouseup</code> se dispara cuando se suelta un botón
								del ratón sobre
								un elemento.
							</p>
							<button onclick="ejecutarMouseUp()">Ejecutar Mouse Up</button>
							<div id="container-ejemplo-mouseup"></div>

							<!-- MOUSEMOVE -->
							<li>
								<h3>Mouse Move</h3>
							</li>
							<p>
								El evento <code class="code-js">mousemove</code> se dispara cuando se mueve el ratón
								dentro de un
								elemento.
							</p>
							<button onclick="ejecutarMouseMove()">Ejecutar Mouse Move</button>
							<div id="container-ejemplo-mousemove"></div>

							<!-- KEYDOWN -->
							<li>
								<h3>Key Down</h3>
							</li>
							<p>
								El evento <code class="code-js">keydown</code> se dispara cuando se presiona una
								tecla.
							</p>
							<button onclick="ejecutarKeyDown()">Ejecutar Key Down</button>
							<div id="container-ejemplo-keydown"></div>

							<!-- KEYUP -->
							<li>
								<h3>Key Up</h3>
							</li>
							<p>
								El evento <code class="code-js">keyup</code> se dispara cuando se suelta una tecla.
							</p>
							<button onclick="ejecutarKeyUp()">Ejecutar Key Up</button>
							<div id="container-ejemplo-keyup"></div>


							<!-- SUBMIT -->
							<li>
								<h3>Submit</h3>
							</li>
							<p>
								El evento <code class="code-js">submit</code> se dispara cuando se envía un
								formulario.
							</p>
							<button onclick="ejecutarSubmit()">Ejecutar Submit</button>
							<div id="container-ejemplo-submit"></div>

							<!-- FOCUS -->
							<li>
								<h3>Focus</h3>
							</li>
							<p>
								El evento <code class="code-js">focus</code> se dispara cuando un elemento gana el
								foco.
							</p>
							<button onclick="ejecutarFocus()">Ejecutar Focus</button>
							<div id="container-ejemplo-focus"></div>

							<!-- BLUR -->
							<li>
								<h3>Blur</h3>
							</li>
							<p>
								El evento <code class="code-js">blur</code> se dispara cuando un elemento pierde el
								foco.
							</p>
							<button onclick="ejecutarBlur()">Ejecutar Blur</button>
							<div id="container-ejemplo-blur"></div>

							<!-- CHANGE -->
							<li>
								<h3>Change</h3>
							</li>
							<p>
								El evento <code class="code-js">change</code> se dispara cuando el valor de un
								elemento cambia.
							</p>
							<button onclick="ejecutarChange()">Ejecutar Change</button>
							<div id="container-ejemplo-change"></div>

							<!-- INPUT -->
							<li>
								<h3>Input</h3>
							</li>
							<p>
								El evento <code class="code-js">input</code> se dispara cuando el valor de un
								elemento de entrada
								cambia.
							</p>
							<button onclick="ejecutarInput()">Ejecutar Input</button>
							<div id="container-ejemplo-input"></div>

							<!-- LOAD -->
							<li>
								<h3>Load</h3>
							</li>
							<p>
								El evento <code class="code-js">load</code> se dispara cuando un recurso y sus
								recursos dependientes
								han terminado de cargar.
							</p>
							<button onclick="ejecutarLoad()">Ejecutar Load</button>
							<div id="container-ejemplo-load"></div>

							<!-- DOMContentLoaded -->
							<li>
								<h3>DOMContentLoaded</h3>
							</li>
							<p>
								El evento <code class="code-js">DOMContentLoaded</code> se dispara cuando el
								documento HTML ha sido
								completamente cargado y parseado.
							</p>
							<button onclick="ejecutarDOMContentLoaded()">Ejecutar DOMContentLoaded</button>
							<div id="container-ejemplo-domcontentloaded"></div>

							<!-- RESIZE -->
							<li>
								<h3>Resize</h3>
							</li>
							<p>
								El evento <code class="code-js">resize</code> se dispara cuando se cambia el tamaño
								de la ventana
								del navegador.
							</p>
							<button onclick="ejecutarResize()">Ejecutar Resize</button>
							<div id="container-ejemplo-resize"></div>

							<!-- SCROLL -->
							<li>
								<h3>Scroll</h3>
							</li>
							<p>
								El evento <code class="code-js">scroll</code> se dispara cuando se desplaza la barra
								de
								desplazamiento de un elemento.
							</p>
							<button onclick="ejecutarScroll()">Ejecutar Scroll</button>
							<div id="container-ejemplo-scroll"></div>
					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-addEventListener-eventos-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-addEventListener-eventos" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo"
					id="pre-ancho100"><code class="code-js" id="code-addEventListener-eventos"></code></pre>
			</section>
			<hr>
			<section id="addEventListener-avanzado">
				<h3>Opciones Avanzadas en addEventListener:</h3>
				<p>Después del primer parámetro “type” y el segundo “Handler” el tercer parámetro (opcional) puede
					ser
					un objeto de configuración:</p>
				<ul>
					<li><code class="code-js">capture</code>: (Booleano) que define si el listener se ejecutará en
						la
						fase
						de captura (<code class="code-js">true</code>) o de burbujeo (<code
							class="code-js">false</code>, por defecto).</li>
					<li><code class="code-js">once</code>: Si es <code class="code-js">true</code>, el listener se
						elimina
						automáticamente después de su primera ejecución.</li>
					<li><code class="code-js">passive</code>: Si es <code class="code-js">true</code>, indica que el
						listener no llamará
						a <code class="code-js">preventDefault()</code>, lo que puede mejorar el rendimiento en
						ciertos
						eventos (por
						ejemplo, en touchstart o wheel).</li>
					<li><code class="code-js">signal</code>: Permite cancelar el listener mediante un objeto
						<code class="code-js">AbortController</code>.
					</li>
				</ul>
				<p>Estas opciones se pueden combinar para crear listeners muy específicos y optimizados para casos
					de
					uso avanzados.</p>
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<h3>Ejemplo Avanzado de addEventListener:</h3>
						<p>
							Crearemos un div con un listener avanzado que reciba un objeto con las opciones:
						</p>
						<ul>
							<li><strong>capture:</strong> (Boolean) en <strong>true</strong> por lo que se ejecutará
								en la fase de captura.</li>
							<li><strong>once:</strong> (Boolean) en <strong>true</strong> por lo que el listener se
								eliminará automáticamente tras su primera ejecución.</li>
							<li><strong>passive:</strong> (Boolean) en <strong>true</strong> por lo que el listener
								no llamará a <code class="code-js">preventDefault()</code>.</li>
							<li><strong>signal:</strong> Permite cancelar el listener mediante un objeto
								<code class="code-js">AbortController</code>, en este caso lo ocuparemos para cancelar
								el listener
								tras 10 segundos.
							</li>
						</ul>
						<p>
							Haz clic en el botón para crear un div con un listener avanzado con estas
							opciones.
						</p>
						<button onclick="ejecutarListenerAvanzado()">Ejecutar Listener Avanzado</button>
						<div id="container-listener-avanzado"></div>


					</div>
					<div class="contenedor-vertical">
						<pre class="pre-largo"
							id="pre-ancho100"><code class="code-js" id="code-addEventListener-avanzado-mostrar"></code></pre>
						<textarea class="resultado-js" id="resultado-addEventListener-avanzado" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo"
					id="pre-ancho100"><code class="code-js" id="code-addEventListener-avanzado"></code></pre>
			</section>
			<hr>
			<section id="casos-Eventos-en-fase-propagacion">
				<h3>Casos de Uso en la Fase de Captura y Burbujeo</h3>
				<h4>Fase de Captura:</h4>
				<ol>
					<li>Validar formularios antes de que los datos se envíen.</li>
					<li>Verificar permisos de acceso al hacer clic en enlaces.</li>
					<li>Registrar interacciones de usuario para análisis global.</li>
					<li>Gestionar eventos de focus en formularios.</li>
					<li>Capturar eventos personalizados a nivel de contenedor.</li>
					<li>Controlar accesos antes de ejecutar acciones específicas.</li>
					<li>Modificar comportamientos predeterminados de elementos de navegación.</li>
					<li>Iniciar operaciones de arrastrar y soltar.</li>
					<li>Gestionar eventos en componentes de forma centralizada.</li>
					<li>Mostrar tooltips de forma anticipada.</li>
				</ol>
				<h4>Fase de Burbujeo:</h4>
				<ol>
					<li>Delegación de eventos en listas o menús.</li>
					<li>Actualización de interfaces en respuesta a interacciones.</li>
					<li>Gestión centralizada de clics en contenedores.</li>
					<li>Ejecución de validaciones de datos tras la interacción del usuario.</li>
					<li>Registro de estadísticas de clics en elementos individuales.</li>
					<li>Manejo de eventos en componentes anidados.</li>
					<li>Optimización de listeners mediante delegación.</li>
					<li>Capturar acciones en formularios para actualizar el estado.</li>
					<li>Responder a eventos de navegación sin interceptar el trigger original.</li>
					<li>Actualizar la UI en respuesta a eventos provenientes de elementos secundarios.</li>
				</ol>
				<p>Recuerda que en ambos casos, puedes detener la propagación del evento usando
					<code class="code-js">stopPropagation()</code> y
					<code class="code-js">stopImmediatePropagation()</code>
					para controlar cómo y dónde se ejecutan los listeners.
				</p>
			</section>
			<hr class="par-js">
			<section id="asincronismo-en-JavaScript">
				<section id="Clase-10-JavaScript-4">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/jk-yW2I0fSc?si=0QLCdIWYA4fHAJRK"
							title="Clase 10 JavaScript 4 parte 1/2 Asincronismo, XMLHttpRequest y más" frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 10 JavaScript 4 parte 1/2 Asincronismo, XMLHttpRequest y más<a
								href="https://www.youtube.com/embed/jk-yW2I0fSc?si=0QLCdIWYA4fHAJRK">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<article id="fundamentos-asincronismo">

					<h2>Fundamentos de Asincronismo en JavaScript</h2>
					<p>
						El asincronismo en JavaScript es un componente esencial que permite la ejecución de tareas en
						segundo plano sin bloquear el hilo principal. Este enfoque no solo mejora la eficiencia y la
						capacidad de respuesta de las aplicaciones web, sino que también optimiza la experiencia del
						usuario al permitir que múltiples operaciones ocurran simultáneamente.
					</p>

					<h3>El Event Loop y el Funcionamiento Interno de V8 en los Navegadores</h3>
					<p>
						El motor JavaScript <code class="code-js">V8</code>, utilizado en navegadores como Google
						Chrome, es responsable de la ejecución de código JavaScript de manera eficiente. En el corazón
						de este funcionamiento está el <code class="code-js">Event Loop</code>, una estructura que
						gestiona la ejecución de código, la recogida de eventos y las tareas asincrónicas. El Event Loop
						asegura que las operaciones se realicen de manera ordenada y no bloquee el hilo principal,
						permitiendo a JavaScript mantener su modelo de ejecución en un solo hilo sin sacrificar la
						capacidad de respuesta y eficiencia.
					</p>

					<h3>JavaScript y su Modelo de Hilo Único</h3>
					<p>Recordando la definición de JavaScript (JS) en MDN, lo describen como un lenguaje de programación
						ligero, interpretado, o compilado justo-a-tiempo (just-in-time) con funciones de primera clase.
						Si bien es más conocido como un lenguaje de scripting (secuencias de comandos) para páginas web,
						y es usado en muchos entornos fuera del navegador, tal como Node.js, Apache CouchDB y Adobe
						Acrobat JavaScript es un lenguaje de programación basada en prototipos, multiparadigma,
						<mark><strong>de un solo hilo</strong></mark>, dinámico, con soporte para programación orientada
						a objetos, imperativa y declarativa (por ejemplo programación funcional).
					</p>
					<h4>Implicaciones de tener un Solo Hilo en JavaScript</h4>
					<strong>Ejecución Síncrona:</strong>
					<p>
						JavaScript utiliza un único <code class="code-js">call stack</code> en el que se apilan
						las funciones a medida que se invocan y se desapilan al finalizar.
					</p>
					<ol>
						<li>
							<strong>Ventajas:</strong>
							<ol type="a">
								<li>
									<strong>Simplicidad y previsibilidad:</strong> No se deben
									gestionar condiciones de carrera propias de múltiples hilos y es más fácil
									el mantenimiento de código al no tener que preocuparse por concurrencia.
								</li>
								<li>
									<strong>Modelo de programación basado en eventos:</strong> JavaScript
									utiliza un modelo de programación basado en eventos y un bucle de eventos.
									Esto permite que el lenguaje maneje múltiples tareas de manera eficiente,
									sin la necesidad de múltiples hilos. Cuando una tarea es asincrónica (como
									una solicitud a un servidor), JavaScript puede continuar ejecutando otras
									tareas mientras espera la respuesta, sin bloquear el hilo principal.
								</li>
							</ol>
						</li>
						<li>
							<strong>Limitación:</strong>
							<ol type="a">
								<li>
									<strong>Riesgo de bloqueo:</strong> El subproceso principal es
									el que usa el navegador para controlar los eventos del usuario, representar
									y pintar la pantalla, y para ejecutar la mayor parte del código que
									comprende una página web o aplicación típica. Debido a que todas estas cosas
									suceden en <mark><strong>un único</strong> subproceso; el <strong>"hilo
											principal"</strong></mark>, un sitio web lento o un script de aplicación
									ralentiza todo el navegador; Peor aún, si el script de un sitio o aplicación entra
									en un bucle infinito, todo el navegador se bloqueará. Esto da como resultado una
									experiencia de usuario frustrante, lenta (o peor).
								</li>
							</ol>
						</li>
					</ol>
					<strong>Implicaciones y Mitigación de Bloqueos</strong>
					<p>
						<strong>Delegación Asíncrona:</strong> Para evitar bloqueos, JavaScript
						delega operaciones costosas (como temporizadores, peticiones de red o manipulación
						de eventos) a mecanismos asíncronos que son gestionados por las <code
							class="code-js">Web APIs</code> del navegador o por <code class="code-js">Node.js</code>.
					</p>
					<p>
						<strong>Resultado:</strong> Aunque el lenguaje se ejecuta en un solo
						hilo, estas operaciones se realizan en “segundo plano” y solo se “devuelven” al hilo
						principal cuando han terminado, evitando congelamientos de la interfaz.
					</p>

					<hr>
					<h3>El Event Loop: Definición y Funcionamiento</h3>
					<p>El <code class="code-js">Event Loop</code> es un bucle infinito que, una vez que el
						<code class="code-js">call stack</code> se encuentra vacío, revisa las colas de tareas y
						mueve las funciones pendientes al <code class="code-js">call stack</code> para su
						ejecución.
					</p>

					<h4>Funcionamiento Básico:</h4>
					<ol>
						<li>
							Ejecuta el código síncrono (se llena y vacía el <code class="code-js">call stack</code>).
						</li>
						<li>
							Una vez vacío, el Event Loop transfiere primero todas las tareas de la <code
								class="code-js">Microtask Queue</code> al <code class="code-js">call stack</code>.
						</li>
						<li>
							Cuando la <code class="code-js">Microtask Queue</code> está vacía, transfiere la
							siguiente tarea de la <code class="code-js">Task Queue</code> (o cola de
							macrotareas).
						</li>
					</ol>

					<fieldset>
						<legend>
							<h4>Estructura del Event Loop</h4>
						</legend>
						<ol>
							<li>
								<strong>Call Stack:</strong> Área donde se ejecuta el código sincrónico.
							</li>
							<li>
								<strong>Microtask Queue:</strong> Prioritaria respecto a la Task Queue. Aquí se encolan
								los
								callbacks de promesas (métodos <code class="code-js">.then()</code>, <code
									class="code-js">.catch()</code>, <code class="code-js">.finally()</code>), así como
								los
								resultados de <code class="code-js">queueMicrotask()</code>.
							</li>
							<li>
								<strong>Task Queue (Cola de Tareas/Macrotareas):</strong> Donde se encolan los callbacks
								de
								funciones asíncronas como las de <code class="code-js">setTimeout</code>, <code
									class="code-js">setInterval</code>, y eventos del DOM. Se procesan en orden FIFO
								cuando
								el <code class="code-js">call stack</code> y la <code
									class="code-js">Microtask Queue</code>
								están vacíos.
							</li>
						</ol>
						<ul>
							<li>
								<strong>Memory Heap:</strong> Aunque no es parte del Event Loop per se, es fundamental:
								es
								el espacio en memoria donde se almacenan objetos y variables. <code
									class="code-js">V8</code> gestiona este heap de forma eficiente mediante un
								recolector
								de basura.
							</li>
						</ul>
					</fieldset>

					<h3>Ejemplo Práctico</h3>
					<pre><code class="code-js">
	console.log('Inicio');
	
	setTimeout(() => {
	console.log('Callback de setTimeout');
	}, 0);
	
	Promise.resolve().then(() => {
	console.log('Callback de la Promesa');
	});
	
	console.log('Fin');
				  </code></pre>
					<button onclick="ejecutarEventLoop1()">Ejecutar</button>
					<textarea id="resultado-EventLoop1" readonly style="display: none;"></textarea>
					<h4>Flujo:</h4>
					<ol>
						<li>
							<strong>Ejecución síncrona:</strong>
							<ul>
								<li>Se imprime "Inicio".</li>
								<li>Se registra el callback de <code class="code-js">setTimeout</code> en la Task
									Queue
									(con un retardo mínimo).</li>
								<li>Se encola el callback de la promesa en la Microtask Queue.</li>
								<li>Se imprime "Fin".</li>
							</ul>
						</li>
						<li>
							<strong>Procesamiento del Event Loop:</strong>
							<ul>
								<li>Al quedar vacío el <code class="code-js">call stack</code>, se vacía primero la
									Microtask Queue: se imprime "Callback de la Promesa".</li>
								<li>Luego, se transfiere el callback de la Task Queue al <code
										class="code-js">call stack</code>: se imprime "Callback de setTimeout".</li>
							</ul>
						</li>
					</ol>
					<p>
						<strong>Resultado final en consola:</strong> Inicio → Fin → Callback de la Promesa →
						Callback de setTimeout.
					</p>
					<div id="mostrarCodigoEventLoop1" style="display: none;"></div>

					<hr>
					<h3>Operaciones Asíncronas y Delegación a las Web APIs</h3>
					<h4>Operaciones Comunes</h4>
					<ul>
						<li>
							<strong>Temporizadores:</strong> <code class="code-js">setTimeout</code> y <code
								class="code-js">setInterval</code> registran sus callbacks en la Task Queue tras
							cumplir
							su retardo mínimo.
						</li>
						<li>
							<strong>Eventos del DOM:</strong> Las interacciones del usuario (clicks, movimientos,
							etc.)
							se encolan de manera similar, permitiendo la respuesta a eventos sin bloquear el hilo
							principal.
						</li>
						<li>
							<strong>Operaciones de I/O:</strong> Peticiones de red (por ejemplo, mediante <code
								class="code-js">fetch</code> o <code class="code-js">XMLHttpRequest</code>) se
							delegan a
							Web APIs que trabajan en segundo plano.
						</li>
					</ul>

					<h4>Delegación a las Web APIs</h4>
					<p><strong>¿Cómo Funciona la delegación a APIs del EventLoop?:</strong></p>
					<p>
						Al detectar una operación asíncrona, el motor JavaScript delega la tarea a la API
						nativa
						del navegador (o Node.js).
					</p>
					<p>
						<strong>Ejemplo:</strong> Al invocar <code class="code-js">fetch()</code>, el
						navegador lanza una petición HTTP en un hilo o proceso aparte, sin bloquear el
						<code class="code-js">call stack</code>. Una vez que la respuesta llega, el
						callback
						se encola (usualmente en la Microtask Queue si se usa con promesas).
					</p>
					<p><strong>Recursos y Subprocesos:</strong></p>
					<p>
						Aunque JavaScript es de un solo hilo, las Web APIs pueden utilizar hilos o
						mecanismos de
						concurrencia propios del entorno para gestionar estas operaciones sin afectar el
						hilo
						principal. Una vez completada la tarea, se “devuelve” la respuesta al Event Loop
						para
						que se ejecute la función correspondiente.
					</p>

					<hr />
					<h2>Flujo Completo de Ejecución en V8</h2>
					<h3>Inicio de la Ejecución</h3>
					<ol>
						<li>
							<strong>Parsing y Compilación:</strong>
							<p>
								<code class="code-js">V8</code> analiza el código, genera un Árbol de Sintaxis
								Abstracta
								(AST) y lo compila a bytecode.
							</p>
						</li>
						<li>
							<strong>Call Stack:</strong>
							<p>
								El código síncrono se ejecuta en el <code class="code-js">call stack</code>, donde
								se
								agregan y eliminan marcos de funciones.
							</p>
						</li>
						<li>
							<strong>Memory Heap:</strong>
							<p>
								Los objetos y variables se asignan en el heap, gestionado por <code
									class="code-js">V8</code> con técnicas de recolección de basura.
							</p>
						</li>
					</ol>

					<h3>Delegación de Tareas Asíncronas</h3>
					<ul>
						<li>
							Al encontrar operaciones asíncronas, <code class="code-js">V8</code> delega estas tareas
							a
							las <code class="code-js">Web APIs</code> del navegador (como temporizadores, peticiones
							HTTP, o eventos del DOM).
						</li>
						<li>
							Estas APIs funcionan en hilos o procesos externos al hilo principal, de modo que no
							bloquean
							el <code class="code-js">call stack</code>.
						</li>
					</ul>

					<mark>
						<h3>Colas y el Event Loop</h3>
					</mark>
					<ol>
						<li>
							<strong>Microtask Queue:</strong>
							<p>
								Prioritaria para tareas derivadas de promesas y <code
									class="code-js">queueMicrotask()</code>.
							</p>
						</li>
						<li>
							<strong>Task Queue (Macrotareas):</strong>
							<p>
								Se encolan callbacks de temporizadores, eventos y operaciones de I/O.
							</p>
						</li>
						<li>
							<strong>Ciclo del Event Loop:</strong>
							<p>
								Mientras el <code class="code-js">call stack</code> esté vacío, el Event Loop
								primero
								procesa todas las microtareas y luego, si no hay ninguna pendiente, transfiere la
								siguiente tarea de la Task Queue.
							</p>
						</li>
					</ol>

					<h3>Ejecución de un Escenario Completo</h3>
					<ul>
						<li>
							<strong>Paso 1:</strong> El código síncrono se ejecuta y se agregan las operaciones
							asíncronas.
						</li>
						<li>
							<strong>Paso 2:</strong> Las Web APIs gestionan la operación asíncrona (por ejemplo, una
							petición con <code class="code-js">fetch()</code>).
						</li>
						<li>
							<strong>Paso 3:</strong> Al completarse, la respuesta se envía al Event Loop; su
							callback se
							encola en la <code class="code-js">Microtask Queue</code> (si es una promesa) o en la Task
							Queue.
						</li>
						<li>
							<strong>Paso 4:</strong> El Event Loop, al detectar un <code
								class="code-js">call stack</code> vacío, procesa primero la <code
								class="code-js">Microtask Queue</code>, pasando su cola de tareas FIFO al Call Stack y
							retornando el control al hilo principal para su ejecución.
						</li>
						<li>
							<strong>Paso 5:</strong> El Event Loop, al detectar un <code
								class="code-js">call stack</code> vacío
							y ver que la <code class="code-js">Microtask Queue</code> también está vacío, procesa la
							<code class="code-js">Task Queue</code>, pasando su cola de tareas FIFO al Call Stack y
							retornando el control al hilo principal para su ejecución.
						</li>
					</ul>

					<h3>Manejo de Eventos y Tareas Pesadas</h3>
					<ul>
						<li>
							<strong>Eventos del DOM:</strong> Se encolan en la <code class="code-js">Task Queue</code> y
							se procesan cuando el
							<code class="code-js">call stack</code> está libre.
						</li>
						<li>
							<strong>Tareas Pesadas:</strong> Para evitar bloquear el hilo principal, se pueden
							dividir
							en fragmentos mediante técnicas como "chunking" o delegar a <code
								class="code-js">Web Workers</code>.
						</li>
					</ul>
					<details>
						<summary>╭☞( ͡ ͡° ͜ ʖ ͡͡°)╭☞ Ver ejemplo de chunking</summary>
						<p>Ejemplo de Chunking: Dividir una tarea pesada en trozos para no bloquear el hilo
							principal.<br>
							En este ejemplo, se realiza una operación matemática intensiva que utiliza Math.PI, Math.E y
							Math.random()
							para simular una carga pesada. La tarea se divide en múltiples "chunks" utilizando
							setTimeout, lo que permite
							que el Event Loop ejecute otras tareas entre cada chunk y mantenga la UI responsiva.</p>

						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">
// Función que simula una operación pesada dividiéndola en chunks
function heavyComputation(totalIterations, chunkSize) {
	let sum = 0;
	let i = 0;
	
	// Función interna que procesa un chunk de iteraciones
	function processChunk() {
	// Calcula el límite para este chunk
	const end = Math.min(i + chunkSize, totalIterations);
	
	// Procesa el chunk realizando operaciones matemáticas intensivas
	for (; i &lt; end; i++) {
		// Realiza una operación matemática utilizando Math.PI, Math.E y Math.random()
		const value = Math.sin(Math.PI * Math.random()) * Math.cos(Math.E * Math.random());
		sum += value;
	}
	
	console.log(`Iteraciones completadas: ${i} / ${totalIterations}`);
	
	// Si no hemos completado todas las iteraciones, agenda el siguiente chunk
	if (i &lt; totalIterations) {
		setTimeout(processChunk, 0);
	} else {
		// Al finalizar, muestra el resultado final
		console.log("Cálculo pesado completado. Suma final:", sum);
	}
	}
	
	// Inicia el procesamiento de chunks
	processChunk();
}

// Ejecuta la tarea pesada con 10 millones de iteraciones en chunks de 100,000
heavyComputation(10000000, 100000);
</code></pre>

					</details>

					<hr>
					<h3>Casos Comunes en Desarrollo Web de Delegación Asíncrona</h3>
					<ul>
						<li>
							<strong>Con XMLHttpRequest (XHR) (Año: 1999):</strong>
							<ul>
								<li>Utilizado tradicionalmente para peticiones asíncronas. Su callback se encola en
									la
									Task Queue al completarse la respuesta.</li>
								<li>Se realiza la petición y el navegador la gestiona en segundo plano.</li>
								<li>Cuando llega la respuesta, el callback se añade a la Task Queue.</li>
							</ul>
						</li>
						<li>
							<strong>Con Promesas y Fetch (Año: 2015):</strong>
							<ul>
								<li>Al utilizar <code class="code-js">fetch()</code>, se retorna una promesa.</li>
								<li>Al resolverse, el callback asociado se agrega a la Microtask Queue, garantizando
									su
									ejecución tan pronto como termine el código síncrono.</li>
							</ul>
						</li>
						<li>
							<strong>Con Async/Await (2017) y Top-Level Await (2022):</strong>
							<ul>
								<li>Sintaxis que permite escribir código asíncrono de forma “síncrona”.</li>
								<li>Bajo el capó, el código después del <code class="code-js">await</code> se encola
									como microtarea.</li>
								<li>Sintaxis moderna para trabajar con operaciones asíncronas. Permite escribir
									código
									más legible, encapsulando la asincronía en bloques <code
										class="code-js">try/catch</code> y transformando el código después de <code
										class="code-js">await</code> en microtareas.</li>
							</ul>
						</li>
					</ul>

					<h3>Tecnologías Adicionales</h3>
					<ul>
						<li>
							<strong>Web Workers:</strong> Permiten ejecutar scripts en hilos paralelos, útiles para
							tareas CPU-intensivas sin afectar la UI.
						</li>
						<li>
							<strong>WebSockets:</strong> Proveen comunicación bidireccional en tiempo real. Sus
							mensajes
							se manejan de forma asíncrona y se integran al flujo del Event Loop mediante callbacks.
						</li>
						<li>
							<strong>Otras APIs del Navegador:</strong> Como Service Workers o APIs de
							notificaciones,
							que también delegan operaciones asíncronas al entorno nativo.
						</li>
					</ul>

					<h3>Resumen del Flujo</h3>
					<ol>
						<li>
							<strong>Ejecución Síncrona:</strong> Código en el <code class="code-js">call stack</code> y
							asignación en el <code class="code-js">Memory Heap</code>.
						</li>
						<li>
							<strong>Delegación Asíncrona:</strong> Tareas como temporizadores, peticiones HTTP y
							eventos
							son delegadas a las <code class="code-js">Web APIs</code>.
						</li>
						<li>
							<strong>Procesamiento de Colas:</strong> El Event Loop gestiona la <code
								class="code-js">Microtask Queue</code> (promesas, async/await) con prioridad, y
							luego la
							<code class="code-js">Task Queue</code> (setTimeout, eventos).
						</li>
						<li>
							<strong>Actualización de UI:</strong> Una vez procesadas las tareas, el navegador
							actualiza
							la interfaz de usuario.
						</li>
					</ol>

					<h3>Buenas Prácticas</h3>
					<ul>
						<li>Evitar operaciones síncronas pesadas.</li>
						<li>Utilizar promesas y async/await para un código más legible y manejable.</li>
						<li>Delegar operaciones costosas a <code class="code-js">Web Workers</code> cuando sea
							posible.
						</li>
						<li>Implementar un manejo robusto de errores en operaciones asíncronas (con <code
								class="code-js">.catch()</code> y bloques <code class="code-js">try/catch</code>).
						</li>
					</ul>

					<h3>Contextualización Histórica</h3>
					<p>
						Brendan Eich creó JavaScript en 1995 para Netscape con el objetivo de
						permitir interactividad mediante callbacks y manejo de eventos, con un enfoque en la
						simplicidad que no incluía un sistema de colas complejas. Operaciones con tiempo, Eventos,
						y XHR utilizan una cola posterior al Call Stack del hilo principal. El modelo de tareas
						con distinción clara entre Task Queue y Microtask Queue evolucionó más tarde, a medida
						que el lenguaje y su uso para el desarrollo de aplicaciones Web crecieron en complejidad
						y robustez.
					</p>
					<p>
						<strong>Evolución:</strong> El concepto del Event Loop y la delegación a <code
							class="code-js">Web APIs</code> se han ido estandarizando y refinando a través de
						ECMAScript y la W3C. La Microtask Queue se introdujo de manera más formal con
						la llegada de las promesas y la especificación de ECMAScript 2015 (ES6).
						Las promesas requirieron un mecanismo para manejar microtareas de forma más eficiente
						y predecible. Por lo tanto, la Microtask Queue se convirtió en una parte integral del
						event loop, permitiendo que las promesas y otras operaciones asíncronas como solicitudes
						HTTP basadas en promesas se ejecuten de manera más rápida y ordenada. Al ejecutarse este
						tipo de operaciones, la clasica función <mark><strong>getData()</strong></mark>,
						(cuya responsablidad es obtener los datos necesarios, procesar los datos recibidos
						para ser información útil y <strong>funcional</strong>), logramos que esta función se
						ejecute y tenga lista la información, <mark><strong>antes</strong></mark> de que se
						ejecuten eventos y actualizaciones de UI.
					</p>

				</article>
			</section>
			<hr class="non-js">
			<section id="http">
				<article id="http-article">
					<h2>HTTP</h2>
					<p>
						<strong>¿Qué es HTTP?</strong><br>
						HTTP (<code class="code-js">HyperText Transfer Protocol</code>) es el protocolo base que permite
						la comunicación entre clientes y servidores en la World Wide Web. Se utiliza para intercambiar
						información, como documentos HTML, imágenes, vídeos y datos estructurados, a través de una red.
						HTTP es un protocolo sin estado, lo que significa que cada solicitud se trata de manera
						independiente sin conocimiento previo de las transacciones anteriores.
					</p>

					<h3>Estructura Completa de una Solicitud HTTP</h3>
					<p>
						Una solicitud HTTP consta de varias partes:
					</p>
					<ul>
						<li>
							<strong>Línea de solicitud (Request Line):</strong>
							<ul>
								<li><strong>Método HTTP</strong>: Indica la acción a realizar (por ejemplo, GET, POST,
									PUT, DELETE).</li>
								<li><strong>URL</strong> o <strong>URI</strong>: Especifica el recurso al que se desea
									acceder.</li>
								<li>
									<strong">Versión del Protocolo</strong>: Generalmente HTTP/1.1 o HTTP/2.
								</li>
							</ul>
						</li>
						<li>
							<strong>Cabeceras (Headers):</strong>
							<ul>
								<li><strong>Host</strong>: El dominio del servidor.</li>
								<li>
									<strong">User-Agent</strong>: Información sobre el cliente (navegador).
								</li>
								<li>
									<strong">Accept</strong>: Tipos de contenido que el cliente puede manejar.
								</li>
								<li>
									<strong">Content-Type</strong>: Tipo de contenido enviado en el cuerpo (en
										solicitudes POST o PUT).
								</li>
								<li>
									<strong">Authorization</strong>: Información para autenticación, si es necesaria.
								</li>
							</ul>
						</li>
						<li>
							<strong>Línea en blanco:</strong> Separa las cabeceras del cuerpo de la solicitud.
						</li>
						<li>
							<strong>Cuerpo (Body):</strong> Es opcional y se utiliza principalmente en solicitudes POST,
							PUT y DELETE. Contiene los datos que se envían al servidor (por ejemplo, datos de formulario
							o JSON).
						</li>
					</ul>
					<p>Ejemplo JSON de body de solicitud HTTP,
						<strong>(en una petición POST, PUT, DELETE):</strong>
					</p>
					<pre><code class="code-js">{
"nombre": "Juan",
"edad": 30
}</code></pre>

					<h3>Métodos HTTP indispensables</h3>
					<ul>
						<li>
							<strong>GET:</strong> Solicita la representación de un recurso. Se utiliza para obtener
							datos sin modificar el estado del servidor.
						</li>
						<li>
							<strong>POST:</strong> Envía datos al servidor para crear un nuevo recurso. El cuerpo de la
							solicitud contiene la información que se desea enviar.
						</li>
						<li>
							<strong>PUT:</strong> Envía datos al servidor para actualizar un recurso existente. Se
							utiliza cuando se quiere reemplazar por completo el recurso.
						</li>
						<li>
							<strong>DELETE:</strong> Solicita la eliminación de un recurso específico.
						</li>
					</ul>

					<h3>Estados de la Solicitud y Códigos de Respuesta HTTP</h3>
					<h4>Estados de la petición (readyState en XHR)</h4>
					<ul>
						<li><strong>0 (UNSENT):</strong> Objeto XHR creado, pero no inicializado.</li>
						<li><strong>1 (OPENED):</strong> <code class="code-js">open()</code> ha sido llamado.</li>
						<li><strong>2 (HEADERS_RECEIVED):</strong> Se han recibido los encabezados de la respuesta.</li>
						<li><strong>3 (LOADING):</strong> La respuesta está en proceso de descarga.</li>
						<li><strong>4 (DONE):</strong> La operación se completó.</li>
					</ul>

					<h4>Códigos de respuesta HTTP</h4>
					<ul>
						<li><strong>1xx (Informativos):</strong>
							<ul>
								<li><code class="code-js">100 continue</code>: Indica que el servidor ha recibido la
									parte inicial de la solicitud y le dice al usuario que puede continuar con el resto
									de la misma.</li>
								<li><code class="code-js">101 Switching Protocols</code>: Indica que el servidor está
									cambiando el protocolo de comunicación en función de una solicitud del cliente (como
									cambiar de HTTP/1.1 a WebSockets).</li>
								<li><code class="code-js">102 Processing</code>: Esto le dice al usuario que el servidor
									ha aceptado la solicitud pero aún está trabajando en procesarla.</li>
							</ul>
						</li>
						<li><strong>2xx (Éxito):</strong>
							<ul>
								<li><code class="code-js">200 OK</code>: La solicitud se completó exitosamente.</li>
								<li><code class="code-js">201 Created</code>: Un recurso fue creado como resultado de la
									solicitud.</li>
							</ul>
						</li>
						<li><strong>3xx (Redirección):</strong>
							<ul>
								<li><code class="code-js">301 Moved Permanently</code>: El recurso se ha movido de forma
									permanente a una nueva URL.</li>
								<li><code class="code-js">302 Found</code>: Redirección temporal.</li>
							</ul>
						</li>
						<li><strong>4xx (Errores del Cliente):</strong>
							<ul>
								<li><code class="code-js">400 Bad Request</code>: La solicitud no se puede procesar por
									error del cliente.</li>
								<li><code class="code-js">401 Unauthorized</code>: Requiere autenticación.</li>
								<li><code class="code-js">404 Not Found</code>: El recurso no fue encontrado.</li>
							</ul>
						</li>
						<li><strong>5xx (Errores del Servidor):</strong>
							<ul>
								<li><code class="code-js">500 Internal Server Error</code>: Error genérico del servidor.
								</li>
								<li><code class="code-js">503 Service Unavailable</code>: El servidor no puede procesar
									la solicitud actualmente.</li>
							</ul>
						</li>
					</ul>
				</article>
			</section>

			<hr class="par-js">
			<section id="xhr">
				<article id="xhr-article">
					<h2>XMLHttpRequest (XHR) (Año: 1999)</h2>
					<p>
						XMLHttpRequest (XHR) fue desarrollado inicialmente por Microsoft y presentado en
						Internet Explorer 5 en 1999 como parte de la tecnología ActiveX. Su finalidad era
						permitir la comunicación asíncrona entre el navegador y el servidor, lo que marcó el
						comienzo del desarrollo de aplicaciones web interactivas.
					</p>

					<p>
						Con el tiempo, XHR fue estandarizado y se integró en el ecosistema de JavaScript. Fue
						adoptado por otros navegadores y eventualmente se incluyó en las especificaciones de
						ECMAScript, consolidándose como una herramienta clave para el desarrollo web asíncrono.
					</p>

					<h3>Funcionamiento de XMLHttpRequest</h3>
					<p>
						El objeto XHR permite enviar solicitudes HTTP y recibir respuestas de forma asíncrona. Su
						funcionamiento se basa en dos componentes principales: el objeto <code
							class="code-js">Request</code> (solicitud) y el objeto <code class="code-js">Response</code>
						(respuesta).
					</p>

					<h4>Objeto Request (Solicitud)</h4>
					<ol>
						<li>
							<strong>Inicialización:</strong>
							<p>
								Se crea una instancia de XMLHttpRequest.
								<br><code class="code-js">const xhr = new XMLHttpRequest();</code>
							</p>
						</li>
						<li>
							<strong>Método open():</strong>
							<p>
								Configura la solicitud especificando el método (GET, POST, PUT, DELETE), la URL y si la
								solicitud debe ser asíncrona.
								<br><code class="code-js">xhr.open("GET", "https://api.ejemplo.com/data", true);</code>
							</p>
						</li>
						<li>
							<strong>Configuración de cabeceras:</strong>
							<p>
								Se pueden añadir cabeceras personalizadas utilizando el método <code
									class="code-js">setRequestHeader</code>.
								<br><code
									class="code-js">xhr.setRequestHeader("Content-Type", "application/json");</code>
							</p>
						</li>
						<li>
							<strong>Envío de la solicitud:</strong>
							<p>
								Con <code class="code-js">send()</code> se inicia la petición. Si se envían datos (en
								POST o PUT), se incluyen como parámetro.
								<br><code class="code-js">xhr.send();</code>
							</p>
						</li>
					</ol>

					<h4>Objeto Response (Respuesta)</h4>
					<ul>
						<li>
							<strong>readyState y status:</strong>
							<p>
								La propiedad <code class="code-js">readyState</code> indica el estado de la solicitud,
								mientras que <code class="code-js">status</code> proporciona el código de estado HTTP de
								la respuesta.
							</p>
						</li>
						<li>
							<strong>responseText y responseXML:</strong>
							<p>
								Dependiendo del tipo de datos, se puede acceder a la respuesta como texto o XML.
								<br>
								<code class="code-js">responseText</code>: Contiene la respuesta en formato de
								texto.<br>
								<code class="code-js">responseXML</code>: Contiene la respuesta en formato XML (si
								aplica).
							</p>
						</li>
					</ul>
					<p>
						Me parece importante mencionar que además de <code class="code-js">onreadystatechange</code>,
						existen otros eventos útiles
						como <code class="code-js">onload</code> (cuando la solicitud se completa exitosamente),
						<code class="code-js">onerror</code> (cuando ocurre un error), y <code
							class="code-js">ontimeout</code> (si la solicitud excede el tiempo límite).
					</p>

					<p>
						<strong>Timeout:</strong>
						Se puede establecer un tiempo límite para la solicitud mediante la propiedad <code
							class="code-js">timeout</code> y gestionar el evento <code class="code-js">ontimeout</code>.
					</p>
					<pre><code class="code-js">xhr.timeout = 5000; // 5 segundos
xhr.ontimeout = function() {
console.error("La solicitud excedió el tiempo límite.");
};</code></pre>

				</article>

				<hr>
				<article id="AJAX">
					<h3>AJAX (Asynchronous JavaScript and XML)</h3>
					<p>
						AJAX es más una técnica o patrón de desarrollo que una tecnología en sí misma. Su principal
						objetivo es permitir que una página web actualice solo las partes necesarias sin necesidad de
						recargarla completamente. Esto se logra mediante la combinación de:
					</p>
					<ul>
						<li><strong>JavaScript:</strong> Para enviar y manejar las solicitudes.</li>
						<li><strong>XMLHttpRequest (XHR):</strong> La API que permite realizar solicitudes HTTP de forma
							asíncrona.</li>
						<li><strong>XML (y hoy en día JSON):</strong> Formatos de datos para intercambiar información
							entre el cliente y el servidor.</li>
					</ul>
					<p>
						El término AJAX se popularizó alrededor del año 2005, impulsado por aplicaciones web innovadoras
						como Gmail y Google Maps, que demostraron cómo era posible hacer interfaces más dinámicas y
						responsivas. Aunque originalmente se usaba XML, actualmente es común utilizar JSON por su mayor
						simplicidad y eficiencia.
					</p>
					<p>
						En resumen, <mark><strong>AJAX</strong> encaja como la técnica que utiliza <strong>XHR (y ahora
								también Fetch)</strong> para hacer
							solicitudes asíncronas, permitiendo <strong>actualizar dinámicamente</strong> partes de la
							página web <strong>sin
								recargarla por completo.</strong></mark>
					</p>
					<p>
						AJAX utiliza XHR para realizar peticiones al servidor en segundo plano. Cuando el servidor
						responde, JavaScript puede actualizar dinámicamente partes de la página web sin necesidad de
						recargarla completamente.
					</p>
					<p>
						Con la evolución hacia APIs modernas, AJAX se ha enriquecido mediante el uso de promesas, Fetch,
						async/await y Top-Level await, facilitando la actualización dinámica de la UI con mayor fluidez
						y eficiencia gracias al EventLoop que encola las CallBack de promesas en la Microtask Queue
						garantizando que se ejecuten antes que la Task Queue con los eventos para actualizar el DOM.
					</p>
				</article>

				<hr>
				<article id="json">
					<h2>JSON</h2>
					<p>
						JSON (<code class="code-js">JavaScript Object Notation</code>) es un formato de texto ligero
						para el intercambio de datos. Se basa en la sintaxis de los objetos de JavaScript, lo que lo
						hace fácil de leer y escribir tanto para humanos como para máquinas. Actualmente, es el formato
						de datos preferido en el desarrollo web por su simplicidad, interoperabilidad y amplio soporte
						en diversos lenguajes de programación.
					</p>
					<h3>Ventajas de JSON</h3>
					<ul>
						<li><strong>Ligero y legible:</strong> Su estructura simple lo hace fácil de entender.</li>
						<li><strong>Facilidad de integración:</strong> La mayoría de los lenguajes tienen funciones o
							librerías nativas para parsear y serializar JSON.</li>
						<li><strong>Interoperabilidad:</strong> Es ideal para el intercambio de datos entre el cliente y
							el servidor.</li>
					</ul>
					<h3>Procesamiento de JSON en JavaScript</h3>
					<p>
						JSON se basa en la sintaxis de los objetos literales de JavaScript, lo que permite utilizar
						funciones nativas como <code class="code-js">JSON.parse()</code> para convertir una cadena JSON
						en un objeto y <code class="code-js">JSON.stringify()</code> para convertir un objeto en una
						cadena.
					</p>
					<h4>Parseo y Serialización</h4>
					<ul>
						<li>Parseo: Convertir una cadena JSON en un objeto JavaScript.</li>
						<pre><code class="code-js">const jsonString = '{ "nombre": "Juan", "edad": 30 }';
const obj = JSON.parse(jsonString);
console.log(obj.nombre); // "Juan"</code></pre>
						<li>Serialización: Convertir un objeto JavaScript en una cadena JSON.</li>
						<pre><code class="code-js">const user = { nombre: "Ana", edad: 25 };
const jsonStr = JSON.stringify(user);
console.log(jsonStr); // { "nombre": "Ana", "edad": 25 }</code></pre>
					</ul>

					<h3>Estructura y Sintaxis de JSON</h3>
					<ul>
						<li>
							<strong>Objetos:</strong> Conjunto de pares clave-valor, delimitados por llaves <code
								class="code-js">{ }</code>.
						</li>
						<li>
							<strong>Arreglos:</strong> Listas ordenadas de valores, delimitados por corchetes <code
								class="code-js">[ ]</code>.
						</li>
					</ul>
					<details>
						<summary>
							╭☞( ͡ ͡° ͜ ʖ ͡͡°)╭☞ Ejemplo JSON: Representación de un Partido de Fútbol
						</summary>
						<p>
							Imaginemos que queremos representar toda la información relevante de un partido de fútbol:
							detalles del partido, equipos, jugadores, marcador y eventos significativos (goles,
							tarjetas).
						</p>
						<pre><code class="code-js">
{
"matchId": 12345,
"date": "2025-03-07T18:30:00Z",
"stadium": "Estadio Nacional",
"referee": "Carlos Pérez",
"teams": {
	"home": {
	"name": "Los Leones",
	"coach": "Miguel Hernández",
	"players": [
		{ "number": 1, "name": "Juan Martínez", "position": "Portero" },
		{ "number": 4, "name": "Pedro Gómez", "position": "Defensa" },
		{ "number": 8, "name": "Luis Ramírez", "position": "Centrocampista" },
		{ "number": 10, "name": "Andrés López", "position": "Delantero" }
	]
	},
	"away": {
	"name": "Los Tigres",
	"coach": "Ricardo Silva",
	"players": [
		{ "number": 1, "name": "Carlos Ruiz", "position": "Portero" },
		{ "number": 5, "name": "Diego Fernández", "position": "Defensa" },
		{ "number": 7, "name": "José Castro", "position": "Centrocampista" },
		{ "number": 9, "name": "Fernando Díaz", "position": "Delantero" }
	]
	}
},
"score": {
	"home": 2,
	"away": 1
},
"events": [
	{
	"minute": 15,
	"type": "goal",
	"team": "home",
	"player": "Andrés López",
	"description": "Gol desde fuera del área."
	},
	{
	"minute": 35,
	"type": "yellow_card",
	"team": "away",
	"player": "Diego Fernández",
	"description": "Falta dura."
	},
	{
	"minute": 60,
	"type": "goal",
	"team": "home",
	"player": "Luis Ramírez",
	"description": "Cabeceo perfecto."
	},
	{
	"minute": 78,
	"type": "goal",
	"team": "away",
	"player": "Fernando Díaz",
	"description": "Remate cruzado."
	}
]
}
				  </code></pre>
						<p>
							En este ejemplo, se modela la información de un partido incluyendo datos generales, equipos,
							jugadores, marcador y eventos, utilizando la estructura de objetos y arreglos propia de
							JSON.
						</p>
						<h3>Ejemplo: Comparación de Porteros</h3>
						<p>
							Te invito a que a partir del JSON que representa un partido de fútbol, obtener un resultado
							con la cantidad de goles que recibió el portero del equipo local (porteroA) y del equipo
							visitante (porteroB).
						</p>
						<p>
							Utiliza la API <code class="code-js">JSON</code> para parsear los datos y mostrar en
							pantalla:
						</p>
						<ul>
							<li>Al <strong>porteroA</strong> (del equipo local) le metieron X goles a favor del equipo
								visitante.</li>
							<li>Al <strong>porteroB</strong> (del equipo visitante) le metieron X goles a favor del
								equipo local.</li>
							<li>El ganador es: el equipo que anotó más goles.</li>
						</ul>
						<button id="btn-comparar-partido" onclick="ejecutarJSONPartido()">Comparar Porteros</button>
						<div id="resultadoPartido"></div>
					</details>
				</article>
				<hr>
				<section id="ejemplos-xhr">
					<div class="contenedor-codigo-resultado">
						<div class="explicacion">
							<h3>Ejemplos de XMLHttpRequest (XHR) con jsonplaceholder</h3>
							<blockquote>
								<p>En este ejemplo utilizaremos <code class="code-js">XMLHttpRequest</code> para probar
									los
									métodos <code class="code-js">GET</code>, <code class="code-js">POST</code>, <code
										class="code-js">PUT</code> y <code class="code-js">DELETE</code> utilizando la
									URL
									correspondiente al método por ejemplo GET con:
									<code class="code-js"><a href="https://jsonplaceholder.typicode.com/todos/1" target="_blank" rel="noopener noreferrer">
								https://jsonplaceholder.typicode.com/todos/1
							</a></code> cada botón ejecutará la operación con la URL correspondiente.<br>
									<cite>
										Puedes ver la documentación de la API en: <a
											href="https://jsonplaceholder.typicode.com/" target="_blank"
											rel="noopener noreferrer">JSONPlaceholder API</a>
									</cite>
								</p>
							</blockquote>

							<ul>
								<li><strong>GET:</strong> <code
										class="code-js">https://jsonplaceholder.typicode.com/todos/1</code></li>
								<button id="btn-get">Ejecutar GET</button>
								<li><strong>POST:</strong> <code
										class="code-js">https://jsonplaceholder.typicode.com/posts</code></li>
								<button id="btn-post">Ejecutar POST</button>
								<li><strong>PUT:</strong> <code
										class="code-js">https://jsonplaceholder.typicode.com/posts/1</code></li>
								<button id="btn-put">Ejecutar PUT</button>
								<li><strong>DELETE:</strong> <code
										class="code-js">https://jsonplaceholder.typicode.com/posts/1</code></li>
								<button id="btn-delete">Ejecutar DELETE</button>
							</ul>
						</div>
						<div class="contenedor-vertical">
							<pre class="pre-largo"
								id="pre-ancho100"><code class="code-js" id="code-XHR-mostrar"></code></pre>
							<textarea class="resultado-js" id="resultado-XHR" readonly></textarea>
						</div>
					</div>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-XHR"></code></pre>

				</section>
			</section>
			<hr class="par-js">
			<section id="explicacion-promesas">
				<section id="Clase-11-JavaScript-4-parte-2/2-Asincronismo-actual">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/Hf24-_w-1zM?si=gtH15ODOepSipesi"
							title="Clase 11 JavaScript 4 parte 2/2 Asincronismo actual: promesas, fetch, async/await y Top level Await." frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 11 JavaScript 4 parte 2/2 Asincronismo actual: promesas, fetch, async/await y Top level Await<a
								href="https://www.youtube.com/embed/Hf24-_w-1zM?si=gtH15ODOepSipesi">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<article id="promesas">
					<h2>Promesas <code class="code-js">"Promise"</code> (Año: 2015 ES6)</h2>
					<p>
						Las <strong>promesas</strong> son objetos que pueden nunca ejecutarse y quedarse en estado
						pendiente, pero fueron diseñadas para representar la eventual finalización (Exitosa o
						fallida) de una operación asíncrona y el manejo de su valor resultante.<br>
						Surgieron como solución al conocido
						"callback hell" o infierno de callbacks, donde la anidación excesiva de funciones callback
						dificultaba la
						legibilidad y el mantenimiento del código.
					</p>

					<h3>¿Qué son las promesas?</h3>
					<p>
						Las promesas permiten encadenar operaciones asíncronas mediante el método <code
							class="code-js">.then()</code>, facilitando así la lectura del flujo de ejecución de manera
						secuencial. Además, se centraliza el manejo de errores utilizando <code
							class="code-js">.catch()</code>, evitando la dispersión de múltiples callbacks de error en
						diferentes niveles de anidación.
					</p>

					<h3>Estados de una promesa</h3>
					<p>
						Una promesa puede estar en uno de estos tres estados:
					</p>
					<ul>
						<li><strong>Pendiente (pending):</strong> Estado inicial, en el que la operación aún no ha
							concluido.</li>
						<li><strong>Resuelta o Cumplida (fulfilled):</strong> La operación se completó exitosamente y la
							promesa se resuelve con un valor.</li>
						<li><strong>Rechazada (rejected):</strong> La operación falló y la promesa se rechaza con un
							error o motivo.</li>
					</ul>

					<h3>Parámetros y métodos fundamentales</h3>
					<p>
						Una Promise es un objeto cuyo constructor recibe una función, conocida como
						<strong>executor</strong>,
						que a su vez recibe dos funciones: <code class="code-js">resolve</code> y <code
							class="code-js">reject</code>.
					</p>
					<ul>
						<li><code class="code-js">resolve</code>: Función que se invoca para indicar que la operación se
							completó exitosamente, pasando el valor resultante.</li>
						<li><code class="code-js">reject</code>: Función que se invoca para indicar que la operación
							falló, pasando el error o motivo.</li>
					</ul>
					<pre><code class="code-js">const miPromesa = new Promise((resolve, reject) => {
// Aquí va el código asíncrono
let exito = true; // Simula el resultado de una operación asíncrona

if (exito) {
	resolve('La operación fue exitosa');
} else {
	reject('La operación falló');
}
});

miPromesa.then((mensaje) => {
console.log(mensaje); // 'La operación fue exitosa'
}).catch((error) => {
console.error(error); // 'La operación falló'
});</code></pre>
					<p>
						En este ejemplo, <code class="code-js">resolve</code> se llama si la operación es exitosa, y
						<code class="code-js">reject</code>
						se llama si la operación falla.
						<code class="code-js">.then()</code> maneja el caso exitoso y <code
							class="code-js">.catch()</code> maneja el error.
					</p>

					<h3>Manejo de errores y encadenamiento</h3>
					<p>
						En JavaScript, el método <code class="code-js">.then()</code> se utiliza para manejar promesas
						cumplidas y rechazadas. Existen dos variantes:
					</p>
					<p>
						<strong><code class="code-js">then(onFulfilled)</code></strong>: Se ejecuta cuando la promesa se
						cumple. <code class="code-js">onFulfilled</code> es una función que recibe el valor de la
						promesa cumplida.
					</p>
					<p>
						El resultado de la promesa se suele trabajar de dos formas diferentes:
					</p>
					<p>
						Con <strong><code class="code-js">then(onFulfilled, onRejected)</code></strong>: Similar al
						anterior, pero además incluye <code class="code-js">onRejected</code>, una función que se
						ejecuta cuando la promesa es rechazada.
						La similitud con la promesa original <code
							class="code-js">new Promise((resolve, reject) => {})</code> radica en que <code
							class="code-js">onFulfilled</code> actúa como <code class="code-js">resolve</code> y <code
							class="code-js">onRejected</code> como <code class="code-js">reject</code>.
					</p>
					<p>
						Ejemplo:
					</p>
					<pre><code class="code-js">const p1 = new Promise((resolve, reject) => {
resolve("Success!");
// o
// reject(new Error("Error!")); // dependiendo del caso de uso
});

p1.then(
(value) => {
	console.log(value); // Success!
},
(reason) => {
	console.error(reason); // Error!
}
);</code></pre>
					<p>
						<hr>
					<h4>Separando el <code class="code-js">.then</code>, <code class="code-js">.catch</code> y <code
							class="code-js">.finally</code></h4>
					<strong><code class="code-js">.catch()</code></strong>: Es una forma de manejar errores similar
					a <code class="code-js">then(undefined, onRejected)</code>. Se utiliza para atrapar cualquier
					error que se produzca en cualquier parte del proceso asíncrono.
					</p>
					<pre><code class="code-js">p1.catch((reason) => {
	console.error(reason); // Error!
	});</code></pre>
					<p>
						<strong><code class="code-js">.finally()</code></strong>: Se ejecuta al final de la cadena de
						promesas, independientemente de si la promesa se cumplió o fue rechazada. Es útil para realizar
						tareas de limpieza.
					</p>
					<pre><code class="code-js">p1.finally(() => {
	console.log("Operación completada, éxito o fallo.");
	});</code></pre>

					<p>Ejemplo:</p>
					<pre><code class="code-js">miPromesa
.then((valor) => {
	console.log('Promesa cumplida con:', valor);
})
.catch((error) => {
	console.error('Error capturado:', error);
})
.finally(() => {
	console.log('Operación finalizada.');
});</code></pre>
					<hr>
					<p>Por lo tanto:</p>

					<ul>
						<li>
							<code class="code-js">.then(onFulfilled, onRejected?)</code>:
							Permite especificar funciones callback para manejar el valor cuando la promesa se cumple o
							para manejar errores (opcionalmente).
						</li>
						<li>
							<code class="code-js">.catch(onRejected)</code>:
							Se utiliza para capturar errores en la cadena de promesas, centralizando el manejo de
							excepciones.
						</li>
						<li>
							<code class="code-js">.finally(onFinally)</code>:
							El método .finally() es especialmente útil para ejecutar código de limpieza o actualizar la
							interfaz, ya que se ejecuta independientemente del resultado de la promesa. Esto es crucial
							en escenarios en los que se necesita liberar recursos o notificar al usuario que la
							operación asíncrona ha terminado.
						</li>
					</ul>

					<p>
						Al encadenar múltiples <code class="code-js">.then()</code>, cada uno devuelve una nueva
						promesa, lo que permite realizar operaciones secuenciales sin necesidad de utilizar múltiples
						callbacks anidados, lo cual mejora la legibilidad y mantenibilidad del código.
					</p>

					<h3>Promesas y el Event Loop</h3>
					<p>
						Las promesas se integran al flujo de ejecución de JavaScript mediante la <code
							class="code-js">Microtask Queue</code>. Cuando una promesa se resuelve o rechaza, el
						callback especificado en <code class="code-js">.then()</code>, <code
							class="code-js">.catch()</code> o <code class="code-js">.finally()</code> se coloca en dicha
						cola. Antes de que el Event Loop procese la <code class="code-js">Task Queue</code>, vacía la
						<code class="code-js">Microtask Queue</code>, garantizando que las operaciones basadas en
						promesas se ejecuten de manera prioritaria y tan pronto como el <code
							class="code-js">call stack</code> esté libre.
					</p>

					<h3>Métodos avanzados de las Promesas</h3>
					<p>
						Existen otros métodos estáticos en el objeto <code class="code-js">Promise</code> que permiten
						trabajar con múltiples promesas:
					</p>
					<ul>
						<li>
							<strong><code class="code-js">Promise.all(iterable)</code>:</strong>
							Recibe un iterable de promesas y devuelve una nueva promesa que se resuelve cuando todas las
							promesas se han resuelto, o se rechaza si alguna de ellas falla.
						</li>
						<li>
							<strong><code class="code-js">Promise.race(iterable)</code>:</strong>
							Devuelve una promesa que se resuelve o rechaza tan pronto como la primera promesa del
							iterable se resuelva o se rechace.
						</li>
						<li>
							<strong><code class="code-js">Promise.allSettled(iterable)</code>:</strong>
							Devuelve una promesa que se resuelve después de que todas las promesas se han cumplido o
							rechazado, con un array de resultados que indica el estado de cada promesa.
						</li>
						<li>
							<strong><code class="code-js">Promise.any(iterable)</code>:</strong>
							Devuelve una promesa que se resuelve tan pronto como cualquier promesa del iterable se
							resuelva; si todas son rechazadas, se rechaza con un AggregateError.
						</li>
					</ul>
					<pre><code class="code-js">
// Ejemplo de Promise.all
const promesas = [
Promise.resolve(1),
Promise.resolve(2),
Promise.resolve(3)
];

Promise.all(promesas)
.then(resultados => {
	console.log('Resultados:', resultados); // [1, 2, 3]
})
.catch(error => {
	console.error('Error en Promise.all:', error);
});
	</code></pre>

					<h3>¡Presta atención!</h3>
					<p>Nota que las promesas son para trabajar con operaciones asincronas pero no necesariamente de red
						mediante solicitudes HTTP, la API Fetch utiliza promesas para trabajar específicamente
						solicitudes HTTP con promesas asegurando trabajar con la Microtask Queue en lugar de la Task
						Queue como XHR.</p>
					<p>Tanto las promesas como la API fetch son de 2015 (ES6) y naturalmente en lo que más se utilizan
						las promesas es por debajo de la Fetch API, pero me parece necesario saber trabajar con promesas
						para saber gestionar el EventLoop con la Microtask Queue y la Task Queue en conjunto dentro del
						asincronismo en JavaScript. Independientemente de si es para trabajar con solicitudes HTTP,
						para lo cual esta la API fetch.
					</p>
					<p>
						Las promesas revolucionaron el manejo de operaciones asíncronas en JavaScript al ofrecer un
						flujo secuencial y más legible en comparación con los callbacks anidados. Considera estudiar
						en profundidad métodos como <code class="code-js">Promise.all</code>,
						<code class="code-js">Promise.race</code>, <code class="code-js">Promise.allSettled</code>
						y <code class="code-js">Promise.any</code>, estos métodos amplían las posibilidades para
						trabajar con múltiples operaciones asíncronas de manera simultánea.
					</p>
				</article>
			</section>

			<hr class="non-js">
			<section id="fetch-api">
				<article id="introduccion-fetch">
					<h2>Fetch API (2015 ES6)</h2>
					<p>
						La <code class="code-js">Fetch API</code> es una interfaz moderna que permite realizar
						peticiones HTTP de manera sencilla, limpia y basada en promesas. Está diseñada para reemplazar
						el tradicional objeto <code class="code-js">XMLHttpRequest</code> (XHR), ofreciendo una sintaxis
						más legible y una integración nativa con las nuevas características de JavaScript, como las
						<code class="code-js">Promise</code> y <code class="code-js">async/await</code>. Esto se traduce
						en un código menos anidado
						(evitando el "callback hell") y en un manejo de errores más centralizado.
					</p>
					<h3>Ventajas frente a XHR</h3>
					<ul>
						<li>
							<strong>Sintaxis clara y moderna:</strong> La API utiliza promesas, lo que permite encadenar
							operaciones asíncronas con <code class="code-js">.then()</code>, <code
								class="code-js">.catch()</code> y <code class="code-js">.finally()</code>.
						</li>
						<li>
							<strong>Mejor manejo de errores:</strong>
							La promesa devuelta por <code class="code-js">fetch()</code> se rechaza solo en caso de
							errores de red o de CORS, lo que obliga a verificar el estado de la respuesta (usando <code
								class="code-js">response.ok</code>).
						</li>
						<ol>
							<li>
								<strong>Errores de red:</strong> Esto ocurre cuando hay un problema al intentar
								conectarse con el servidor. En estos casos, la promesa devuelta por `fetch()` será
								rechazada con un objeto de error del tipo `TypeError`.
								<ul>
									<li>El servidor está inaccesible (fuera de línea).</li>
									<li>No tienes conexión a Internet.</li>
									<li>El DNS no puede resolver el nombre de dominio del servidor.</li>
									<li>Hay un error de tiempo de espera (timeout).</li>
								</ul>
							</li>
							<li>
								<strong>Errores de CORS (Cross-Origin Resource Sharing):</strong> Si se intenta realizar
								una solicitud que infringe las políticas de seguridad de CORS, el navegador bloquea la
								solicitud antes de que se envíen datos al servidor, y la promesa será rechazada como un
								`TypeError`.
								<ul>
									<li>Cuando el servidor no incluye los encabezados correctos para permitir la
										comunicación desde un origen diferente.</li>
									<li>Si estás haciendo una solicitud desde un sitio a otro dominio y no hay permisos
										explícitos establecidos.</li>
								</ul>
							</li>
						</ol>

						<strong>Importante:</strong> Si la solicitud HTTP se completa exitosamente pero la
						respuesta es un código de error HTTP (como 404 o 500), la promesa no se rechaza. En
						este
						caso, la promesa se resuelve correctamente, pero debes verificar la propiedad <code
							class="code-js">ok</code> del objeto de respuesta para determinar si la
						solicitud
						fue exitosa.



						<li>
							<strong>Mayor flexibilidad:</strong> Proporciona objetos <code
								class="code-js">Request</code> y
							<code class="code-js">Response</code>, que permiten
							configurar con precisión la petición y manipular la respuesta de forma detallada.
						</li>
						<li>
							<strong>Integración con async/await:</strong> Permite escribir código asíncrono de forma
							más
							natural y legible.
						</li>
					</ul>
				</article>

				<article id="fetch-request-response">
					<h2>Fetch API y window.fetch</h2>
					<p>
						La función <code class="code-js">fetch()</code> se utiliza para iniciar una petición HTTP.
						Recibe como parámetro obligatorio la URL del recurso y, opcionalmente, un objeto de
						configuración.
					</p>
					<fieldset>
						<legend>
							<h3>Objetos Request y Response</h3>
						</legend>
						<h4>Objeto Request</h4>
						<p>
							El objeto <code class="code-js">Request</code> encapsula toda la información relativa a la
							petición HTTP:
						</p>
						<ul>
							<li>
								<strong>URL y Método:</strong> Especifica a qué recurso se accede y qué método HTTP se
								utiliza (<code class="code-js">GET</code>, <code class="code-js">POST</code>, <code
									class="code-js">PUT</code>, <code class="code-js">DELETE</code>, etc.).
							</li>
							<li>
								<strong>Headers:</strong> Permite definir cabeceras personalizadas como <code
									class="code-js">Content-Type</code>, <code class="code-js">Authorization</code>,
								entre
								otras. La interfaz <code class="code-js">Headers</code> ofrece métodos para agregar,
								modificar o consultar los encabezados.
							</li>
							<li>
								<strong>Body:</strong> Para métodos como <code class="code-js">POST</code> o <code
									class="code-js">PUT</code>, se puede enviar un cuerpo que contenga datos (por
								ejemplo,
								en formato JSON o FormData).
							</li>
							<li>
								<strong>Configuración avanzada:</strong>
								<ul>
									<li><code class="code-js">mode</code>: Controla el comportamiento de la solicitud en
										cuanto a seguridad y CORS (<code class="code-js">cors</code>, <code
											class="code-js">no-cors</code>, <code class="code-js">same-origin</code>).
									</li>
									<li><code class="code-js">credentials</code>: Indica si se deben enviar cookies
										junto a
										la petición (<code class="code-js">omit</code>, <code
											class="code-js">same-origin</code>, <code class="code-js">include</code>).
									</li>
									<li><code class="code-js">cache</code>: Define estrategias de caché (<code
											class="code-js">default</code>, <code class="code-js">no-cache</code>, <code
											class="code-js">reload</code>, etc.).</li>
									<li><code class="code-js">Abort Signal</code>: Mediante el uso de <code
											class="code-js">AbortController</code>, es posible cancelar una petición en
										curso.</li>
								</ul>
							</li>
						</ul>
						<p>
							<strong>Ejemplo de creación explícita:</strong>
						</p>
						<pre><code class="code-js">const request = new Request('https://api.example.com/data', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json'
	},
	body: JSON.stringify({ nombre: 'Ana', edad: 25 })
});</code></pre>

						<hr>
						<h4>Objeto Response</h4>
						<p>
							El objeto <code class="code-js">Response</code> representa la respuesta HTTP obtenida y
							ofrece
							múltiples utilidades:
						</p>
						<ul>
							<li>
								<strong>Estado y Validación:</strong>
								<ul>
									<li><code class="code-js">status</code>: Código HTTP (ej. 200, 404).</li>
									<li><code class="code-js">statusText</code>: Texto descriptivo del estado.</li>
									<li><code class="code-js">ok</code>: Booleano que indica si el status está en el
										rango
										200-299.</li>
								</ul>
							</li>
							<li>
								<strong>Procesamiento del cuerpo de la respuesta en diferentes formatos de
									datos:</strong>
								<p>Con el objeto <code class="code-js">response</code> que devuelve la API Fetch se
									pueden
									hacer operaciones comunes como:</p>
								<ul>
									<li><code class="code-js">response.json()</code>: Indica que la respuesta es un
										JSON.
										Convierte el cuerpo a un objeto
										JavaScript, <mark>observa que por debajo utiliza JSON.parse().</mark></li>
									<li><code class="code-js">response.text()</code>: Devuelve el cuerpo como texto o
										HTML.
									</li>
									<li><code class="code-js">response.blob()</code> y <code
											class="code-js">response.arrayBuffer()</code>: Útiles para contenido binario
										como imágenes, videos, juegos, gráficos, etc.
									</li>
									<li><code class="code-js">response.formData()</code>: Para respuestas en formato de
										datos de formulario.</li>
								</ul>
							</li>
							<li>
								<strong>Headers:</strong> Se puede acceder a los encabezados de la respuesta mediante
								<code class="code-js">response.headers.get('Header-Name')</code>.
							</li>
							<li>
								<strong>Clonación:</strong> Como el cuerpo se consume una única vez, se puede clonar la
								respuesta usando <code class="code-js">response.clone()</code>.
							</li>
						</ul>
					</fieldset>
					<hr>
					<h3>Uso de window.fetch</h3>
					<p>
						La función <code class="code-js">fetch()</code> se utiliza para iniciar una petición HTTP.
						Recibe como parámetro la URL y, opcionalmente, un objeto de configuración.
					</p>
					<h4>Ejemplo GET:</h4>
					<pre><code class="code-js">fetch('https://api.example.com/data')
.then(response => {
	if (!response.ok) {
	throw new Error(`Error HTTP: ${response.status}`);
	}
	return response.json();
})
.then(data => {
	console.log('Datos recibidos:', data);
})
.catch(error => {
	console.error('Error en la petición GET:', error);
});</code></pre>

					<h4>Ejemplo POST:</h4>
					<pre><code class="code-js">fetch('https://api.example.com/data', {
method: 'POST',
headers: {
	'Content-Type': 'application/json'
},
body: JSON.stringify({ nombre: 'Juan', edad: 30 })
})
.then(response => {
	if (!response.ok) {
	throw new Error(`Error HTTP: ${response.status}`);
	}
	return response.json();
})
.then(data => {
	console.log('Recurso creado:', data);
})
.catch(error => {
	console.error('Error en la petición POST:', error);
});</code></pre>

					<h3>Procesamiento de Diferentes Formatos de Datos</h3>
					<p>
						La implementación de window de la Fetch API no cambia nada en el procesamiento del cuerpo de la
						respuesta, se maneja como un <code class="code-js">ReadableStream</code> y se
						puede transformar a varios formatos:
					</p>
					<ul>
						<li><code class="code-js">response.json()</code> para obtener un objeto JavaScript.</li>
						<li><code class="code-js">response.text()</code> para obtener texto plano o HTML.</li>
						<li><code class="code-js">response.blob()</code> o <code
								class="code-js">response.arrayBuffer()</code> para contenido binario.</li>
						<li><code class="code-js">response.formData()</code> para trabajar con datos de formularios.
						</li>
					</ul>
					<h3>Encadenamiento de Promesas con Fetch y Manejo de Respuestas</h3>
					<p>
						La función <code class="code-js">fetch()</code> devuelve una promesa que se resuelve con un
						objeto <code class="code-js">Response</code>. Esto permite encadenar operaciones de
						transformación y procesamiento de datos utilizando <code class="code-js">.then()</code> y
						centralizar el manejo de errores con <code class="code-js">.catch()</code>.
					</p>
					<pre><code class="code-js">
fetch('https://api.example.com/data')
.then(response => {
	if (!response.ok) {
	throw new Error(`Error HTTP: ${response.status}`);
	}
	return response.json(); // Primera transformación
})
.then(jsonData => {
	console.log('JSON recibido:', jsonData);
	// Se puede realizar otra petición 
	// utilizando los datos de la primera
	return fetch('https://api.example.com/another-endpoint');
})
.then(response => response.text())
.then(textData => {
	console.log('Texto recibido:', textData);
})
.catch(error => {
	console.error('Error en la cadena de promesas:', error);
});</code></pre>

					<h3>Manejo de Headers y Configuraciones Avanzadas</h3>
					<p>
						Al enviar una petición con <code class="code-js">fetch()</code>, se pueden incluir headers
						personalizados, por ejemplo: Bearer = Portador
					</p>
					<pre><code class="code-js">fetch('https://api.example.com/data', {
method: 'GET',
headers: {
	'Authorization': 'Bearer miToken123',
	'Accept': 'application/json'
}
});</code></pre>
					<p>
						Asimismo, se puede acceder a los encabezados de la respuesta:
					</p>
					<pre><code class="code-js">fetch('https://api.example.com/data')
.then(response => {
	console.log('Content-Type de la respuesta:', response.headers.get('Content-Type'));
	return response.json();
})
.then(data => {
	console.log('Datos:', data);
})
.catch(error => {
	console.error('Error en la petición:', error);
});</code></pre>

					<hr>
					<h3>Notas importantes de la Fetch API y HTTP</h3>
					<p>
						La Fetch API representa un avance significativo en el manejo de peticiones HTTP en JavaScript,
						ofreciendo:
					</p>
					<ul>
						<li>Sintaxis moderna y clara para encadenar operaciones asíncronas.</li>
						<li>Control detallado de la solicitud a través de objetos <code class="code-js">Request</code> y
							<code class="code-js">Response</code>.
						</li>
						<li>Procesamiento flexible del cuerpo de la respuesta mediante diversos métodos de
							transformación.</li>
						<li>Integración con el Event Loop mediante la Microtask Queue, asegurando una ejecución
							prioritaria.</li>
						<li>
							<details>
								<summary>
									☞( ͡ ͡° ͜ ʖ ͡͡°)╭☞ Existen otros métodos HTTP que te podrían ser útiles si los
									conoces:
								</summary>
								<ul>
									<li><strong>HEAD:</strong> Similar a GET, pero solo solicita los encabezados de
										respuesta sin el cuerpo. Útil para verificar metadatos de un recurso.</li>
									<li><strong>OPTIONS:</strong> Permite al cliente consultar qué métodos HTTP y
										encabezados son admitidos por el servidor para un recurso específico.</li>
									<li><strong>PATCH:</strong> Utilizado para realizar actualizaciones parciales a un
										recurso, en lugar de reemplazarlo por completo como ocurre con PUT.</li>
									<li><strong>TRACE:</strong> Permite al cliente realizar un seguimiento de la ruta
										que sigue una solicitud a través del servidor. Generalmente no se usa en
										producción por razones de seguridad.</li>
									<li><strong>CONNECT:</strong> Usado para establecer conexiones de túnel, como cuando
										se utiliza HTTPS a través de un proxy HTTP.</li>
									<li><strong>PROPFIND (WebDAV):</strong> Utilizado para recuperar propiedades
										(metadatos) de un recurso. Muy común en extensiones como Web Distributed
										Authoring and Versioning (WebDAV).</li>
									<li><strong>PROPPATCH (WebDAV):</strong> Similar a PATCH, pero específicamente para
										modificar las propiedades de un recurso.</li>
									<li><strong>LOCK y UNLOCK (WebDAV):</strong> Permiten bloquear y desbloquear
										recursos para evitar que múltiples usuarios los modifiquen al mismo tiempo.</li>
									<li><strong>MKCOL (WebDAV):</strong> Crea colecciones (carpetas) en un servidor.
									</li>
									<li><strong>SEARCH:</strong> Usado en implementaciones específicas para realizar
										búsquedas en recursos según ciertos criterios.</li>
								</ul>
							</details>
						</li>
					</ul>
				</article>
			</section>
			<hr class="par-js">
			<section id="explicacion-async-await">
				<article id="async-await">
					<h2>Async/Await <code class="code-js">"async/await"</code> (Año: 2017)</h2>
					<p>
						Las palabras clave <strong>async</strong> y <strong>await</strong> se introdujeron en 2017
						(ECMAScript 2017), aproximadamente dos años después de la integración de las promesas y la Fetch
						API (ECMAScript 2015), entendiendo que <code class="code-js">Promise</code> es la base sobre la
						cual el EventLoop gestiona la Microtask Queue y tanto <code class="code-js">fetch</code>, como
						<code class="code-js">async</code>, <code class="code-js">await</code> y <code
							class="code-js">Top-level await</code> (2022) trabajan mediante promesas.
					</p>
					<p>
						Las palabras reservadas <code class="code-js">async</code> y <code class="code-js">await</code>
						surgieron para trabajar de forma más sencilla con operaciones asíncronas, facilitando la lectura
						y escritura de código. La palabra <code class="code-js">async</code> sirve para indicar que una
						función se va a comportar de manera asíncrona, lo que hace posible que dentro de su ámbito o
						scope se pueda utilizar <code class="code-js">await</code> para pausar la ejecución y esperar la
						resolución de la promesa, logrando un código que se puede leer como “haz esto y espera la
						respuesta”, “luego, haz esto otro y espera la respuesta”.
					</p>
					<h3>1. Función Asíncrona (<code class="code-js">async</code>)</h3>
					<p>
						Al anteponer <code class="code-js">async</code> a una función, ésta retorna siempre una promesa,
						incluso si se retorna un valor primitivo.
					</p>
					<h3>2. Pausar la Ejecución (<code class="code-js">await</code>)</h3>
					<p>
						Dentro de una función <code class="code-js">async</code>, <code class="code-js">await</code>
						detiene la ejecución hasta que la promesa se resuelva o se rechace, lo que permite escribir
						código secuencial que se asemeja a código síncrono.
					</p>
					<h3>Ejemplo</h3>
					<pre><code class="code-js">// Declaración de una función asíncrona
async function someAsyncFunction() {
  console.log('Iniciando la petición...');
  // 'await' pausa la ejecución hasta que la promesa se resuelva
  const respuesta = await someFunction(); // función que requiere asincronismo
  // Procesamos la respuesta como JSON u otro proceso intensivo
  const datos = await respuesta.json();
  console.log('Datos recibidos:', datos);
  return datos;
}

// Llamada a la función asíncrona manejada con promesas
obtenerDatos()
  .then(data => console.log('Operación completada:', data))
  .catch(error => console.error('Error en la petición:', error));
</code></pre>
					<p>
						También podríamos hacerlo con <code class="code-js">async</code>, <code
							class="code-js">await</code> y <code class="code-js">try/catch</code>, lo cual se considera
						buena práctica al centralizar el manejo de errores:
					</p>
					<h3>Manejo de Errores con Async/Await</h3>
					<h4>Uso de try/catch</h4>
					<p>
						Captura los errores dentro de una función asíncrona con un bloque <code
							class="code-js">try/catch</code>. Se comienza con <code
							class="code-js">try { // código que puede fallar }</code> y con <code
							class="code-js">catch (error) { // manejo de error }</code>, capturando errores que se
						produzcan, por ejemplo, al esperar la resolución de promesas. Esto es equivalente a utilizar
						<code class="code-js">.catch()</code> en cadenas de promesas, pero de una forma más intuitiva.
					</p>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js">// Declaración de una función asíncrona con try/catch
async function someAsyncFunction() {
  try {
    console.log('Iniciando la petición...');
    // 'await' pausa la ejecución hasta que la promesa se resuelva
    const respuesta = await someFunction(); // función que requiere asincronismo

    // Procesamos la respuesta como JSON u otro proceso intensivo
    const datos = await respuesta.json();
    console.log('Datos recibidos:', datos);

    // Retornamos los datos procesados
    return datos;
  } catch (error) {
    // Capturamos errores, ya sea al ejecutar someFunction() o al procesar los datos
    console.error('Error en la función asincrónica someAsyncFunction():', error);
    throw error; // Propaga el error si necesitas manejarlo en otro nivel
  }
}

// Llamada a la función asíncrona
(async function() {
  try {
    const data = await someAsyncFunction();
    console.log('Operación completada:', data);
  } catch (error) {
    console.error('Error al llamar a obtenerDatos():', error);
  }
})();
</code></pre>
					<p>
						Con <code class="code-js">try/catch</code> puedes capturar cualquier error que ocurra durante la
						ejecución de <code class="code-js">await</code>, ya sea al resolver la promesa o por excepciones
						dentro del bloque <code class="code-js">try</code>.
					</p>
					<h4>Uso de finally – Código de Limpieza</h4>
					<p>
						Al igual que en el manejo de errores sincrónico, el bloque <code class="code-js">finally</code>
						se ejecuta siempre, sin importar si se utilizó el <code class="code-js">.catch()</code> o si se
						completó con éxito. Esto es útil para realizar tareas de limpieza o actualizar la interfaz de
						usuario, y en el back-end para cerrar conexiones a bases de datos.
					</p>
					<pre><code class="code-js">async function obtenerDatosConLimpieza() {
  try {
    const respuesta = await someAsyncFunction();
    const datos = await respuesta.json();
    console.log('Datos recibidos:', datos);
  } catch (error) {
    console.error('Error:', error);
  } finally {
    console.log('La operación asíncrona ha finalizado.');
  }
}
obtenerDatosConLimpieza();
</code></pre>
					<p>
						Por lo tanto, la función que contiene <code class="code-js">await</code> debe ser declarada como
						<code class="code-js">async</code>, lo que hace que siempre retorne una promesa, sin importar si
						devuelve un valor sincrónico o una promesa. El uso de <code class="code-js">await</code> detiene
						la ejecución en ese punto específico hasta que la promesa se resuelva (fulfilled) o se rechace
						(rejected), <strong>sin bloquear el hilo principal</strong>. Una vez que se resuelve la promesa,
						la continuación de la función se coloca en la Microtask Queue y se ejecuta tan pronto como el
						call stack esté vacío.
					</p>
					<p>
						El uso de <code class="code-js">async/await</code> permite escribir código asíncrono en un
						estilo secuencial y, mediante <code class="code-js">try/catch</code>, facilita el seguimiento
						del flujo de ejecución y la detección de errores, en comparación con el encadenamiento de
						múltiples <code class="code-js">.then()</code>.
					</p>
					<h3>Encadenamiento de Promesas con async/await y procesamiento en paralelo</h3>
					<p>
						Si llamas a las promesas de forma secuencial con <code class="code-js">await</code> dentro de un
						bucle o una cadena:
					</p>
					<pre><code class="code-js">async function processSequentially() {
  const result1 = await promise1;
  const result2 = await promise2;
}
</code></pre>
					<p>Cada <code class="code-js">await</code> espera la resolución de la promesa anterior antes de
						pasar a la siguiente, <strong>Esto genera un procesamiento secuencial.</strong>
					<p>
						Ahora, si bien el procesamiento secuencial es bastante útil. Si necesitas disparar las promesas
						en paralelo y procesar los resultados una vez que todas estén resueltas, puedes usar
						<code class="code-js">Promise.all</code>. Recuerda que este método recibe un array de promesas
						o iterable y devuelve una promesa que se resuelve cuando todas se han cumplido, pero si una es
						rechazada la promesa de retorno se rechaza descartando todas las demás promesas hayan sido o
						no cumplidas.
					</p>
					<pre><code class="code-js">async ()=>{
	try {
		const [usuarios, productos, pedidos] = await Promise.all([
		fetch('/api/usuarios').then(res => res.json()),
		fetch('/api/productos').then(res => res.json()),
		fetch('/api/pedidos').then(res => res.json())
	]);
	console.log('Usuarios:', usuarios);
	} catch (error) {
	console.error('Error en una de las solicitudes:', error);
	}
}
</code></pre>
					<p>
						En este caso, las promesas se ejecutan casi al mismo tiempo y su resolución sigue el flujo del
						Event Loop.
					</p>
					<hr>

					<h3>¡Presta atención!</h3>
					<p>Observa el último ejemplo donde utilizamos <code class="code-js">async ()=>{}</code>, es
						importante mencionar que las arrow functions, o funciones flecha <strong>no tienen su propio
							this</strong>, sino que lo heredan del contexto en el que fueron creadas. Esto es diferente
						a las funciones declaradas con <code class="code-js">function</code> que sí tienen su propio
						binding dinámico de <code class="code-js">this</code>, por ello, normalmente se utiliza
						<code class="code-js">function</code>. Sin embargo, si entiendes el comportamiento de this y no
						necesitas
						este binding, es totalmente válido utilizar arrow functions. También se puede declarar un método
						<code class="code-js">async</code> dentro de un objeto, los métodos son funciones basadas en el
						prototipo <strong>Function</strong> y tienen su propio binding de this dinámico con <code
							class="code-js">function</code>. Por otro lado, si se declaran como <code
							class="code-js">myMethod: async ()=>{}</code> arrow functions, <code
							class="code-js">this</code> será heredado del contexto donde fueron creadas, por lo que no
						siempre apuntarán al objeto que las contiene, dependiendo del lugar donde fueron definidas.
					</p>
					<p>
						Nota que las <code class="code-js">async/await</code>, al estar basadas en promesas, son para
						trabajar con operaciones asíncronas, pero no necesariamente de red mediante solicitudes HTTP. La
						API <code class="code-js">Fetch</code> utiliza promesas para trabajar específicamente con
						solicitudes HTTP, asegurando trabajar con la Microtask Queue en lugar de la Task Queue como XHR.
					</p>
					<p>
						Tanto las promesas como la API <code class="code-js">fetch</code> son de 2015 (ES6) y <code
							class="code-js">async/await</code> es de 2017 (ES8), trabajando perfectamente en conjunto,
						ya que todo se basa en promesas. Y como mencioné anteriormente, considero fundamental saber
						trabajar con promesas y <code class="code-js">async/await</code> junto con bloques
						<code class="code-js">try/catch</code> para gestionar el EventLoop con la Microtask Queue y
						la Task Queue en el asincronismo de JavaScript. Independientemente de si es para trabajar
						con solicitudes HTTP, para lo cual está la API fetch.
					</p>
					<p>
						Las promesas revolucionaron el manejo de operaciones asíncronas en JavaScript al ofrecer un
						flujo secuencial y más legible, mejorando la sintaxis al parecerse al código síncrono mediante
						el uso de <code class="code-js">await</code> dentro de funciones <code
							class="code-js">async</code>. Considera estudiar en profundidad métodos como <code
							class="code-js">Promise.all</code>, <code class="code-js">Promise.race</code>, <code
							class="code-js">Promise.allSettled</code> y <code class="code-js">Promise.any</code>, ya que
						amplían las posibilidades para trabajar con múltiples operaciones asíncronas de forma
						simultánea.
					</p>

					<hr>
					<h3>Async/Await y Fetch</h3>
					<p>
						La integración de <code class="code-js">async/await</code> con la Fetch API permite escribir
						código para realizar peticiones HTTP de forma más natural. Al combinar ambos, se pueden realizar
						operaciones secuenciales de forma limpia y legible.
					</p>
					<h4>Ejemplo de Uso con Fetch</h4>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js">// Función asíncrona que realiza una petición GET utilizando fetch y async/await
async function fetchData() {
  try {
    console.log('Iniciando petición GET...');
    const respuesta = await fetch('https://api.example.com/data');
    if (!respuesta.ok) {
      throw new Error(`Error HTTP: ${respuesta.status}`);
    }
    // Procesa la respuesta como JSON
    const datos = await respuesta.json();
    console.log('Datos recibidos:', datos);
    return datos;
  } catch (error) {
    console.error('Error en fetchData:', error);
    throw error;
  } finally {
    console.log('Finalizó la petición GET.');
  }
}

// Llamada a la función
fetchData()
  .then(data => {
    console.log('Operación completada, datos:', data);
  })
  .catch(error => {
    console.error('Error en la cadena de operaciones:', error);
  });
</code></pre>
					<h4>Encadenamiento de Operaciones Secuenciales</h4>
					<p>
						Con <code class="code-js">async/await</code> se pueden encadenar múltiples operaciones
						asíncronas de forma secuencial, lo que es especialmente útil cuando se depende de la respuesta
						de una petición para realizar la siguiente.
					</p>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js">async function procesarDatos() {
  try {
    // Primera petición: Obtener datos
    const respuesta1 = await fetch('https://api.example.com/data');
    if (!respuesta1.ok) {
      throw new Error(`Error HTTP: ${respuesta1.status}`);
    }
    const datos = await respuesta1.json();
    console.log('Datos iniciales:', datos);

    // Segunda petición: Enviar datos para procesamiento
    const respuesta2 = await fetch('https://api.example.com/procesar', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ datos })
    });
    if (!respuesta2.ok) {
      throw new Error(`Error HTTP: ${respuesta2.status}`);
    }
    const resultado = await respuesta2.json();
    console.log('Resultado del procesamiento:', resultado);
    
    return resultado;
  } catch (error) {
    console.error('Error en procesarDatos:', error);
  }
}

procesarDatos();
</code></pre>

				</article>

				<hr>
				<section id="async-await-fetch">
					<div class="contenedor-codigo-resultado">
						<div class="explicacion">
							<h4>Ejemplo Async/Await con fetch consultando la API de Rick y Morty</h4>

							<blockquote>
								<p>En este ejemplo utilizaremos la API de Rick y Morty para hacer una primera solicitud
									a
									<code class="code-js"><a href="https://rickandmortyapi.com/api/location/3" target="_blank" rel="noopener noreferrer">
								https://rickandmortyapi.com/api/location/3
							</a></code>
									para obtener los datos de los personajes que viven en la Citadel of Ricks.
									<cite>
										<a href="https://rickandmortyapi.com/" target="_blank"
											rel="noopener noreferrer">Rick and Morty API</a>
									</cite>
								</p>
							</blockquote>

							<button id="btn-Rick-y-Morty">Ejecutar ejemplo Rick y Morty</button>
							<div id="container-Rick-y-Morty"></div>
						</div>
						<div class="contenedor-vertical">
							<pre class="pre-largo"
								id="pre-ancho100"><code class="code-js" id="code-Rick-y-Morty-mostrar"></code></pre>
							<textarea class="resultado-js" id="resultado-Rick-y-Morty" readonly></textarea>
						</div>
					</div>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js" id="code-Rick-y-Morty"></code></pre>
				</section>
			</section>
			<hr class="non-js">
			<section id="top-level-await">
				<article id="top-level-await">
					<h2>Top-Level Await (Año:2022)</h2>
					<p>
						<strong>¿Qué es Top-Level Await?</strong><br>
						Top-Level Await es una característica de ECMAScript 2022 ES(13) que permite utilizar la palabra
						clave <code class="code-js">await</code> fuera de las funciones <code
							class="code-js">async</code>, es
						decir, en el nivel superior de tus módulos JavaScript. Anteriormente, para esperar el resultado
						de una promesa era necesario encapsular el código asíncrono dentro de una función marcada como
						<code class="code-js">async</code> o emplear una IIFE (Immediately Invoked Function Expression).
						Con Top-Level Await, se elimina esta necesidad, lo que resulta en un código más limpio y
						legible.
					</p>
					<pre><code class="code-js">// Llamada a la función asíncrona IIFE

/* IIFE (Immediately Invoked Function Expression), 
en español "Expresión de Función Invocada Inmediatamente" */

(async function() {
  try {
    const data = await someAsyncFunction();
    console.log('Operación completada:', data);
  } catch (error) {
    console.error('Error al llamar a obtenerDatos():', error);
  }
})();</code></pre>

					<h3>¿Cómo Funciona?</h3>
					<ol>
						<li>
							Cuando el motor JavaScript encuentra un <code class="code-js">await</code> en el nivel
							superior de un módulo, la ejecución del módulo se pausa hasta que la promesa asociada se
							resuelva.
						</li>
						<li>
							Durante esta pausa, el motor puede continuar procesando otros módulos o tareas, sin bloquear
							la ejecución global.
						</li>
						<li>
							Una vez que la promesa se resuelve (o rechaza), la ejecución del módulo se reanuda y el
							resultado de la promesa queda disponible para el resto del código.
						</li>
					</ol>

					<h3>Casos de Uso Comunes</h3>
					<ul>
						<li>
							<strong>Carga Dinámica de Módulos:</strong> Permite esperar la carga de datos esenciales o
							configuraciones antes de importar otros módulos que dependen de dichos datos.
						</li>
						<li>
							<strong>Inicialización de Recursos:</strong> Es útil para inicializar recursos asíncronos,
							como conexiones a bases de datos o clientes de API, antes de ejecutar el resto del código.
						</li>
						<li>
							<strong>Recuperación de Datos Iniciales:</strong> En aplicaciones web, se puede emplear para
							obtener datos del servidor antes de renderizar la interfaz de usuario.
						</li>
					</ul>

					<h3>Implicaciones y Consideraciones</h3>
					<ul>
						<li>
							<strong>Módulos:</strong> Top-Level Await está disponible únicamente en módulos JavaScript
							(archivos con extensión <code class="code-js">.mjs</code> o archivos configurados con <code
								class="code-js">"type": "module"</code> en el <code
								class="code-js">package.json</code>).
						</li>
						<li>
							<strong>Rendimiento:</strong> Un uso excesivo de Top-Level Await puede ralentizar la
							ejecución, ya que retrasa la evaluación de otros módulos hasta que se resuelvan las
							promesas.
						</li>
						<li>
							<strong>Manejo de Errores:</strong> Es fundamental utilizar bloques <code
								class="code-js">try...catch</code> para capturar y gestionar posibles errores durante la
							resolución de las promesas.
						</li>
						<li>
							<strong>Alcance:</strong> Las variables declaradas en el nivel superior de un módulo (con
							<code class="code-js">var</code>, <code class="code-js">let</code> o <code
								class="code-js">const</code>) mantienen su alcance al módulo, lo que favorece la
							encapsulación y evita conflictos globales.
						</li>
					</ul>

					<h3>Ejemplo Práctico</h3>
					<pre><code class="code-js">// module.mjs
try {
// Se espera la resolución de la promesa y se obtienen los datos
const datos = await fetch('https://api.ejemplo.com/datos')
	.then(res => {
	if (!res.ok) {
		throw new Error(`Error HTTP: ${res.status}`);
	}
	return res.json();
	});
console.log('Datos cargados:', datos);

// El resto del código del módulo puede utilizar 'datos'
export function procesarDatos() {
	return datos.map(item => item.valor * 2);
}
} catch (error) {
console.error('Error al cargar datos:', error);
}</code></pre>
					<p>
						En este ejemplo, el módulo espera a que la promesa se resuelva y los datos sean cargados antes
						de continuar con la ejecución. Así, la variable <code class="code-js">datos</code> está
						completamente disponible para el resto del módulo, permitiendo que la función <code
							class="code-js">procesarDatos()</code> trabaje con información actualizada.
					</p>

					<h3>Beneficios Clave</h3>
					<ul>
						<li>Código más limpio y legible, sin necesidad de envoltorios innecesarios.</li>
						<li>Simplifica la carga dinámica de módulos y la inicialización de recursos asíncronos.</li>
						<li>Facilita la recuperación de datos iniciales antes de que se ejecute el resto del código.
						</li>
					</ul>
				</article>

			</section>
			<hr class="par-js">
			<section id="ejemplo-asincronismo-completo">
				<h2>Ejemplo Completo de Asincronismo en JavaScript</h2>
				<p>
					En este ejemplo se realizará una primera solicitud a la API de Rick and Morty para
					obtener la ubicación "Citadel of Ricks" en la URL:
					<code class="code-js">https://rickandmortyapi.com/api/location/3</code>.
					A partir de la respuesta, se extraerán los primeros 4 URLs de residentes y se harán 4
					solicitudes individuales empleando métodos diferentes:
					<br>
					<strong>1.</strong> Fetch con promesas (then/catch).<br>
					<strong>2.</strong> Fetch con async/await y try/catch.<br>
					<strong>3.</strong> Fetch con Top-Level Await (simulado dentro de la función, recordando
					que Top-Level Await se usa a nivel global en módulos con <code class="code-js">type="module"</code>
					o
					archivos <code class="code-js">.mjs</code>).<br>
					<strong>4.</strong> Solicitud XHR.
				</p>
				<p>
					Además se integrará un <code class="code-js">dispatchEvent</code> para demostrar la
					propagación de
					eventos en el DOM (la manipulación del DOM se realiza en la Task Queue) y se usará
					<code class="code-js">setTimeout</code> para simular tareas delegadas al Event Loop.
				</p>
				<p>
					Antes de comenzar, Me gustaría explicar que todo el código se ejecuta en el Call Stack,
					donde se asigna memoria en el Heap (gestión de objetos y variables), y luego se delegan las
					operaciones asíncronas a las colas de Microtareas (Microtask Queue) y Macrotareas (Task
					Queue). Una vez que el Call Stack se vacía, el Event Loop procesa primero la Microtask Queue
					(FIFO) y luego la Task Queue, permitiendo la interacción responsiva con la UI.
				</p>
				<div class="contenedor-codigo-resultado">
					<div class="explicacion">
						<blockquote>
							<p>En este ejemplo utilizaremos la API de Rick y Morty para hacer una primera solicitud a
								<code class="code-js"><a href="https://rickandmortyapi.com/api/location/3" target="_blank" rel="noopener noreferrer">
								https://rickandmortyapi.com/api/location/3
							</a></code>
								para obtener los datos de los primeros 4 personajes que viven en la Citadel of Ricks.
								<cite>
									<a href="https://rickandmortyapi.com/" target="_blank"
										rel="noopener noreferrer">Rick and Morty API</a>
								</cite>
							</p>
						</blockquote>
						<button id="btn-asincronismo-completo">Ejecutar ejemplo Rick y Morty</button>
						<div id="container-asincronismo-completo"></div>
					</div>
					<div class="contenedor-vertical">
						<textarea class="resultado-js" id="resultado-asincronismo-completo" readonly></textarea>
					</div>
				</div>
				<pre class="pre-largo"
					id="pre-ancho100"><code class="code-js" id="code-asincronismo-completo"></code></pre>

			</section>
			<hr class="non-js">
			<section id="testing">
				<section id="Clase-12-JavaScript-5-Pruebas-Unitarias">
					<figure>
						<iframe width="560" height="315" src="https://www.youtube.com/embed/nG5KfCMpR0c?si=71qCS8AQJ6Q7LBkY"
							title="Clase 12 JavaScript 5 Pruebas Unitarias." frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
							referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<figcaption>Vídeo de <cite>Ricardo López Arriaga Bueno </cite>Clase 12 JavaScript 5 Pruebas Unitarias.<a
								href="https://www.youtube.com/embed/nG5KfCMpR0c?si=71qCS8AQJ6Q7LBkY">@rickylobu en
								YouTube</a></figcaption>
					</figure>
				</section>
				<article id="explicacion-testing">
					<h2>Testing en el Desarrollo de Software</h2>
					<p>
						<strong>¿Por qué hacer pruebas?</strong>
					<ul>
						<li><strong>Verificación y Calidad:</strong> Las pruebas aseguran que cada parte del código
							funcione según lo esperado, previniendo errores y regresiones.</li>
						<li><strong>Documentación Viva:</strong> Los tests actúan como una forma de documentación que
							describe el comportamiento esperado de las funciones, facilitando la comprensión del código
							a nuevos desarrolladores.</li>
						<li><strong>Facilita el Refactoring:</strong> Con una suite de tests robusta, se pueden hacer
							cambios y mejoras en el código con la confianza de que cualquier error será detectado
							rápidamente.</li>
						<li><strong>Integración en CI/CD:</strong> Las pruebas automatizadas se integran en pipelines de
							integración continua, permitiendo feedback inmediato y manteniendo la estabilidad del
							software en cada ciclo de desarrollo o sprint.</li>
					</ul>
					</p>
					<hr>
					<h3>Tipos de Pruebas y su Categorización</h3>
					<h4>1. Pruebas Unitarias</h4>
					<p>
						Las pruebas unitarias verifican el comportamiento de la unidad más pequeña del código
						(funciones, métodos o clases). Son rápidas de ejecutar y se enfocan en un alcance muy
						específico. Se emplean mocks, stubs y spies para aislar el componente bajo prueba. Se recomienda
						probar funciones que contengan lógica de negocio, interacciones con el DOM o cálculos complejos.
					</p>
					<h4>2. Pruebas de Integración</h4>
					<p>
						Estas pruebas evalúan la interacción entre múltiples componentes o módulos, asegurando que se
						integren correctamente. Se utilizan escenarios reales o simulados para comprobar la comunicación
						entre distintas partes del sistema.
					</p>
					<h4>3. Pruebas End-to-End (E2E) y de Sistema</h4>
					<p>
						Simulan el comportamiento del usuario y validan el sistema completo, desde la interfaz hasta la
						base de datos. Aunque son más lentas y complejas, son fundamentales para la validación final del
						producto. En entornos de producción se recomienda investigar frameworks como Cypress, Selenium,
						Protractor o TestCafe.
					</p>
					<hr>
					<h3>Estrategias de Testing</h3>

					<p>En el desarrollo de software, las estrategias de testing son fundamentales para garantizar la
						calidad, la funcionalidad y la estabilidad del código. A continuación, se describen las
						principales estrategias:</p>

					<ul>
						<li>
							<strong>TDD (Test Driven Development):</strong> <em>(Desarrollo Guiado por Pruebas)</em>
							<p>
								Se basa en escribir <strong>primero las pruebas</strong> antes del código. El flujo
								típico de TDD sigue estos pasos:
							</p>
							<ol>
								<li>Escribir una prueba mínima que inicialmente falle (porque el código aún no existe).
								</li>
								<li>Escribir el código necesario para que la prueba pase.</li>
								<li>Refactorizar el código para hacerlo más eficiente o limpio, asegurándose de que las
									pruebas sigan pasando.</li>
							</ol>
							<p>
								Este enfoque asegura que el código esté respaldado por pruebas desde el principio,
								facilitando la refactorización con confianza y reduciendo defectos en etapas
								posteriores. TDD se centra en el cumplimiento de los requisitos funcionales de manera
								estrictamente técnica.
							</p>
						</li>
						<li>
							<strong>BDD (Behavior Driven Development):</strong> <em>(Desarrollo Guiado por
								Comportamiento)</em>
							<p>
								Se enfoca en el <strong>comportamiento esperado</strong> del sistema desde la
								perspectiva del negocio o del usuario final. Se utilizan herramientas como Cucumber o
								lenguaje semiestructurado (por ejemplo, Gherkin: <code
									style="color: white;">Given, When, Then</code>) para
								describir escenarios claros y entendibles por todas las partes interesadas.
							</p>
							<p>Ejemplo de un escenario en BDD:</p>
							<pre><code style="color: white;">Feature: Suma de números
Scenario: Sumar dos números
    Given tengo los números 2 y 3
    When los sumo
    Then el resultado debería ser 5</code></pre>
							<p>
								BDD fomenta la colaboración entre desarrolladores, testers y stakeholders para
								garantizar que el producto cumpla con los requerimientos esperados.
							</p>
						</li>
						<li>
							<strong>Automatización:</strong>
							<p>
								Consiste en implementar <strong>pruebas automatizadas</strong> que se ejecutan en cada
								commit, integración o despliegue, comúnmente a través de pipelines de CI/CD (Integración
								y Entrega Continua). Esto permite:
							</p>
							<ul>
								<li>Detectar errores rápidamente antes de que lleguen a producción.</li>
								<li>Reducir esfuerzos manuales y optimizar el tiempo.</li>
								<li>Mantener un sistema confiable y libre de regresiones.</li>
							</ul>
							<p>
								Las pruebas automatizadas incluyen pruebas unitarias (con TDD), pruebas de integración y
								pruebas E2E (End-to-End), cubriendo así todo el espectro funcional del sistema.
							</p>
						</li>
					</ul>

					<h4>Cómo se complementan TDD, BDD y Automatización</h4>
					<p>
						El flujo ideal combina estas estrategias:
					</p>
					<ol>
						<li>
							<strong>Inicio del ciclo:</strong> Se definen los requerimientos funcionales y no
							funcionales, y se planea la arquitectura del sistema.
						</li>
						<li>
							<strong>Escenarios en BDD:</strong> A partir de los requerimientos, se escriben escenarios
							de comportamiento para detallar cómo debería funcionar el sistema desde el punto de vista
							del usuario final.
						</li>
						<li>
							<strong>Implementación con TDD:</strong> Para cada escenario, se escriben pruebas unitarias
							específicas y luego el código que haga pasar esas pruebas. Este enfoque asegura que cada
							unidad del sistema cumpla su propósito técnico.
						</li>
						<li>
							<strong>Automatización:</strong> Las pruebas (unitarias, de integración, E2E) se integran en
							pipelines automatizados, ejecutándose con cada cambio para garantizar estabilidad continua.
						</li>
					</ol>

					<p>
						Combinando estas estrategias, se logra un desarrollo más colaborativo (BDD), técnicamente sólido
						(TDD) y confiable (automatización), lo que facilita el mantenimiento, escalabilidad y calidad
						del producto.
					</p>

					<h3>Integración en CI/CD y Metodologías Ágiles:</h3>
					<p>
						<em>Continuous Integration and Continuous Delivery/Deployment</em> (CI/CD) Significa Integración
						Continua y Entrega/Implementación Continua. Estas prácticas buscan optimizar y acelerar el ciclo
						de vida del desarrollo de software mediante la automatización de la integración, las pruebas y
						la implementación de los cambios de código.
					</p>
					<h4>Integración Continua (CI)</h4>
					<p>
						La <stong>Integración Continua (CI):</stong> consiste en integrar de forma automática y
						frecuente los cambios de
						código de varios desarrolladores en un repositorio de código fuente compartido. Este proceso
						implica herramientas automatizadas que compilan el código recién confirmado, ejecutan pruebas
						unitarias y realizan revisiones de código. Los objetivos principales de la CI son identificar y
						corregir errores rápidamente, facilitar la integración del código, mejorar la calidad del
						software y reducir el tiempo necesario para lanzar nuevas funcionalidades.
					</p>
					<p>
						Pipelines de CI: Herramientas como Jenkins, CircleCI, Travis CI, Bamboo o los propios pipelines
						de GitLab/Azure DevOps ejecutan la suite de pruebas (unitarias, integración y en algunos casos
						E2E) en cada commit o pull request.
					</p>
					<p>
						Pruebas de Commit: Los tests de TDD/TDB se ejecutan en cada commit para detectar errores
						tempranos y garantizar que las nuevas implementaciones no rompan la funcionalidad existente.
					</p>
					<h4>Entrega Continua (CD):</h4>
					<p>
						La <strong>Entrega Continua (CD):</strong> amplía la CI al automatizar el proceso de
						lanzamiento, garantizando que los cambios en el código se prueben en un entorno similar al de
						producción antes del despliegue. Esta práctica ayuda a evitar sorpresas de última hora y
						garantiza que el código siempre esté listo para su implementación. La CD implica ejecutar
						pruebas de integración y regresión en un entorno de pruebas, lo que hace que el proceso de
						lanzamiento final sea más fluido y confiable.
					</p>
					<p>
						Despliegue Continuo: (Automatiza el despliegue en producción tras pasar todas las pruebas). En
						entornos de Staging y Producción, una vez que las pruebas en CI se aprueban, el código se
						despliega en entornos de staging para validaciones más completas (incluyendo pruebas de
						integración y E2E) y, finalmente, en producción.
					</p>
					<h5>¿Qué pruebas llegan a producción?</h5>
					<ul>

						<li>Pruebas en el Pipeline: Generalmente, las pruebas unitarias, de integración y E2E se
							ejecutan en los entornos de CI/CD y staging.</li>
						<li>Smoke Tests y Sanity Checks: En producción se pueden ejecutar pruebas de humo (smoke tests)
							o chequeos de sanidad que validen rápidamente que la aplicación está operativa, pero las
							pruebas completas se realizan antes del despliegue.</li>
						<li>Excepción: No se “despliegan” pruebas en producción, sino que se utilizan para validar que
							el build es estable antes del despliegue. Con esto me refiero a que <strong>No se despliega
								la suite completa de pruebas en producción.</strong><br>
							Los tests se usan en las fases de desarrollo, integración y staging para garantizar la
							estabilidad del build. En producción se pueden ejecutar pruebas de humo o sanity checks para
							asegurarse de que el sistema está operativo, pero las pruebas detalladas (unitarias,
							integración y E2E) se ejecutan en entornos controlados antes del despliegue.</li>
					</ul>

					<p>
						<strong>Pruebas en el Proceso CI/CD:</strong> En entornos de desarrollo frontend con JavaScript
						se utilizan herramientas como Jasmine, Mocha/Chai, Jest o QUnit para validar el comportamiento
						de las funciones y la interacción del DOM (usando mocks, stubs y spies).Mientras que en el
						Back-End, dependiendo del lenguaje, se pueden usar frameworks específicos (por ejemplo, JUnit
						en Java o NUnit en .NET). El objetivo es validar que los diferentes módulos o componentes se
						integren correctamente mediante herramientas como (Postman, Newman o frameworks de pruebas
						integradas en el entorno de desarrollo).
					</p>
					<hr>
					<h3>Beneficios del Testing para Equipos y Proyectos</h3>
					<p><Strong>¡Recuerda porqué es importante que codifiques tus test: pruebas unitarias y en su momento
							de integración y E2E!</Strong></p>
					<ul>
						<li><strong>Documentación y Transferencia de Conocimiento:</strong> Los tests actúan como una
							“documentación viva” que describe cómo se espera que funcione cada parte del código,
							facilitando la incorporación de nuevos desarrolladores.</li>
						<li><strong>Confianza en el Código:</strong> Contar con pruebas unitarias e integradas brinda
							seguridad para realizar cambios y refactorizaciones sin temor a romper funcionalidades.</li>
						<li><strong>Calidad Continua:</strong> La integración de tests en pipelines CI/CD garantiza una
							calidad constante y la detección temprana de problemas, lo que se traduce en un software más
							estable y confiable.</li>
					</ul>
					<hr class="par-js">
					<h3>Pruebas unitarias en JavaScript</h3>
					<p>
						Nosotros abordaremos en detalle las pruebas unitarias que es lo correspondiente a nuestro tema
						de estudio: “Fundamentos de Desarrollo Web”. Considero que para ser un desarrollador Web o
						“front-end developer” es fundamental saber hacer pruebas unitarias de tu código de forma
						competente y profesional, por lo que profundizaremos en las pruebas unitarias en JavaScript y tu
						responsabilidad es aprender lo correspondiente al “Testing “ en el futuro de tu carrera
						profesional.
					</p>
					<h4>Conceptos Básicos: Mocks, Stubs y Spies</h4>
					<p>
						<strong>Stubs:</strong> Son funciones o métodos que reemplazan una función o dependencia real
						para devolver resultados fijos. Su principal objetivo es aislar la función en prueba,
						controlando el comportamiento de sus dependencias. Así, se garantiza que, ante ciertos inputs,
						la función retorne un valor fijo, facilitando la
						validación del comportamiento, sin depender de la lógica real de la dependencia, sin la
						complejidad completa de un mock.
					</p>
					<p>
						<strong>Spies:</strong> Son envoltorios (wrappers) Su función principal es envolver ( "espiar")
						o interceptar llamadas a funciones reales. Registran información (número de invocaciones,
						argumentos, contexto, etc.) y, en algunos casos, también el resultado devuelto. sin modificar el
						comportamiento original, lo que ayuda a verificar que la función se comporte como una función
						pura en el sentido de que sus interacciones sean predecibles y observables. Por ejemplo, los
						spies son útiles para verificar que se hayan llamado funciones específicas durante la ejecución
						de una prueba.
					</p>
					<p>
						<strong>Mocks:</strong> Un mock es un objeto que en muchos casos, combina las funcionalidades de
						stubs y spies. Es decir, un mock no solo devuelve valores predefinidos (como un stub) sino que
						también registra las interacciones (como un spy). Además, los mocks se configuran con
						expectativas específicas: pueden validar que se hayan llamado con ciertos parámetros, que se
						hayan producido las interacciones en un orden determinado o que se hayan lanzado errores
						esperados en situaciones particulares. Si esas expectativas no se cumplen, la prueba falla.
					</p>
					<p>
						Son objetos simulados que imitan el comportamiento de objetos reales. Además de definir
						respuestas preestablecidas, registran cómo fueron llamados para luego verificar interacciones.
						Suelen usarse para validar que una función haya llamado a otro componente de forma correcta.
					</p>
					<h4>¿Por qué y Cuándo Usar Mocks?</h4>
					<ul>
						<li><strong>Aislamiento de la Prueba:</strong> Permiten que la prueba se ejecute sin depender
							del comportamiento de una dependencia externa.</li>
						<li><strong>Verificación de Interacciones:</strong> Registran información sobre las llamadas
							realizadas, facilitando la validación del flujo de interacción entre módulos.</li>
						<li><strong>Control del Comportamiento:</strong> Permiten simular escenarios difíciles de
							reproducir con la dependencia real, como errores de red.</li>
						<li><strong>Documentación del Contrato:</strong> Actúan como una documentación viva que
							especifica cómo se espera que interactúe un módulo con sus dependencias.</li>
					</ul>
					<hr>
					<h3>Ejemplos Prácticos</h3>
					<p>Analicemos primero un ejemplo con JavaScript puro (Vanilla JavaScript).</p>
					<section id="mocks-js-valilla">
						<h4>Ejemplo de Mocks con JavaScript</h4>
						<p>Podemos crear un mock manual para una función que, por ejemplo, envíe un mensaje. Imaginemos
							que
							tenemos un módulo que debe enviar un mensaje y queremos asegurarnos de que se llame
							correctamente a la función de envío: <code class="code-js">enviarMensaje()</code> se muestra
							cómo simular la función y validar que se haya llamado con el mensaje esperado.</p>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">// Función real que usaríamos para enviar un mensaje 
//(podría ser una llamada HTTP, etc.)
function enviarMensaje(mensaje) {
console.log("Mensaje enviado:", mensaje);
return true;
}

// Mock de enviarMensaje
function crearMockEnviarMensaje() {
const mock = function(mensaje) {
	mock.llamadas.push(mensaje);
	return true;
};
mock.llamadas = [];
mock.esperarLlamadaCon = function(esperado) {
	if (!mock.llamadas.includes(esperado)) {
	throw new Error(`Se esperaba que se llamara con: ${esperado}`);
	}
};
return mock;
}

// Ejemplo de uso del mock
const mockEnviarMensaje = crearMockEnviarMensaje();
function procesarYEnviar(mensaje) {
// Lógica adicional puede ir aquí
return mockEnviarMensaje(mensaje);
}

procesarYEnviar("Hola mundo");
mockEnviarMensaje.esperarLlamadaCon("Hola mundo");</code></pre>
						<p>En este ejemplo se crea un mock para la función enviarMensaje que registra cada llamada en un
							array (llamadas) y se añade un método esperarLlamadaCon para validar que la función haya
							sido llamada con un argumento específico.</p>

					</section>

					<hr>
					<article id="instalacion-nvm-npm-node-js">
						<h2>Guía para Instalar NVM y Node.js</h2>
						<p>Llegado este punto es necesario instalar Node.js para poder ejecutar las pruebas
							correctamente.
							Pero espera!, no instales Node todavía, te recomiendo hacerlo mediante Node Version Manager
							(NVM)</p>
						<p>Node.js es un entorno de ejecución para JavaScript que te permite ejecutar código JavaScript
							fuera de un navegador, por ejemplo, en servidores. Está basado en el motor V8 de Chrome, lo
							que
							lo hace rápido y eficiente. Node.js es usado principalmente para desarrollar aplicaciones
							backend, pero también puede servir para herramientas de desarrollo frontend.</p>
						<p>npm es el gestor de paquetes (Node Package Manager) que viene incluido con Node.js. Es una
							herramienta que facilita la instalación, gestión y uso de librerías y dependencias (módulos)
							en
							tus proyectos.</p>
						<h3>Con Node.js y npm puedes:</h3>
						<ul>
							<li>Configurar herramientas de desarrollo como Webpack, Babel, Jest, Jasmine etc..</li>
							<li>Usar frameworks como Angular, React o Vue.</li>
							<li>Administrar dependencias de manera eficiente en proyectos grandes.</li>
							<li>Crear servidores backend.</li>
						</ul>
						<p>Por ejemplo, si necesitas usar una librería externa como un marco de pruebas, un framework
							web o
							cualquier tipo de utilidad, puedes instalarlo desde npm en tu proyecto con unos pocos
							comandos,
							incluso puedes publicar tus módulos en el registro de npm.</p>
						<h3>¿Por qué NVM?</h3>
						<p>NVM (Node Version Manager) te permite instalar y cambiar fácilmente entre diferentes
							versiones de
							Node.js. Esto es útil para proyectos que requieren versiones específicas de Node.js.</p>
						<p>NVM es esencial para trabajar con diferentes versiones de Node.js en un mismo sistema. Esto
							evita
							conflictos y facilita la gestión de proyectos con dependencias específicas.</p>
						<p>La instalación varía ligeramente entre macOS/Linux y Windows:</p>

						<h3>Instalación de NVM en Windows</h3>
						<ol>
							<li>Descarga el instalador de NVM para Windows desde el repositorio de GitHub: <a
									target="_blank"
									href="https://github.com/coreybutler/nvm-windows/releases">nvm-windows</a>.</li>
							<li>Ejecuta el instalador y sigue las instrucciones.</li>
							<li>Abre una nueva terminal como Administrador y verifica la instalación ejecutando:
								<pre><code class="code-js">nvm --version</code></pre>
							</li>
						</ol>
						<h3>Instalación de NVM en macOS y Linux</h3>
						<ol>
							<li>Abre tu terminal.</li>
							<li>Ejecuta el siguiente comando:
								<pre><code class="code-js">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</code></pre>
							</li>
							<li>Cierra y vuelve a abrir tu terminal para que los cambios surtan efecto.</li>
							<li>Verifica la instalación ejecutando:
								<pre><code class="code-js">nvm --version</code></pre>
							</li>
						</ol>
						<h3>Instalación de Node.js con NVM</h3>
						<ol>
							<li>Ejecuta el siguiente comando para instalar la versión LTS (Long Term Support) más
								reciente
								de Node.js:
								<pre><code class="code-js">nvm install --lts</code></pre>
							</li>
							<li>Ejecuta el siguiente comando para usar la versión LTS (Long Term Support) instalada
								de Node.js:
								<pre><code class="code-js">nvm use xx.xx.x</code></pre>
							</li>
							<li>Verifica la instalación ejecutando:
								<pre><code class="code-js">node --version</code></pre>
								<pre><code class="code-js">npm --version</code></pre>
								<ol>
									<li>Si no pudiste ejecutar npm --version. Ver la política actual de ejecución:
										<code class="code-js">Get-ExecutionPolicy</code>
										Esto mostrará la política actual. Probablemente estará configurada en
										Restricted.
									</li>
									<li>Cambiar la política de ejecución:
										Para permitir la ejecución de scripts, usa este comando:
										<code class="code-js">Set-ExecutionPolicy RemoteSigned</code>
										Esto permite ejecutar scripts locales sin firmar, pero requiere que los scripts
										descargados de Internet estén firmados digitalmente.
									</li>
									<li>Confirmar el cambio:
										Escribe Y (Yes) o S (Si) y presiona Enter cuando se te pida confirmación.</li>
									<li>Ejecuta nuevamente:
										<code class="code-js">Get-ExecutionPolicy</code>
										Asegúrate de que ahora diga RemoteSigned.
									</li>
									<li>Probar nuevamente el comando npm:
										<code class="code-js">npm --version</code>
										Ahora debería funcionar correctamente.
									</li>
								</ol>
							</li>
							<li>Para ver la lista de versiones puedes utilizar <code class="code-js">nvm list</code>. Si
								quieres utilizar una versión específica de Node.js, ejecuta:
								<pre><code class="code-js">nvm use [versión]</code></pre>
							</li>
						</ol>

						<hr>
						<h3>Instalación de frameworks de pruebas</h3>
						<p>Para instalar jest ejecuta el siguiente comando:</p>
						<pre><code class="code-js">npm install --save-dev jest</code></pre>
						<p>para instalar Jasmine ejecuta:</p>
						<pre><code class="code-js">npm install --save-dev jasmine</code></pre>
						<p>para instalar Mocha y Chai ejecuta:</p>
						<pre><code class="code-js">npm install --save-dev mocha chai</code></pre>
						<p>para instalar QUnit ejecuta:</p>
						<pre><code class="code-js">npm install --save-dev qunit</code></pre>
					</article>

					<hr>
					<section id="entendiendoPackage.json">
						<h4>Entendiendo un poco <code class="code-js">package.json</code></h4>
						<p>Imagina que quieres tener Jest y Jasmine en el mismo proyecto. Tu <code
								class="code-js">package.json</code> quedaría algo así:</p>
						<pre><code style="color: white">{
"name": "fundametos-de-desarrollo-Web",
	"version": "1.0.0",
	"description": "Pruebas unitarias con Jest y Jasmine para ejemplos del proyecto",
	"type": "module",
	<mark>"scripts": {
	"test:jasmine": "jasmine",
	"test:jest": "jest",
	"test": "npm run test:jasmine && npm run test:jest"
	},
	"devDependencies": {
	"jest": "^29.7.0",
	"babel-jest": "^29.7.0",
	"@babel/core": "^7.21.0",
	"@babel/preset-env": "^7.21.0"
	}</mark>
}</code></pre>

						<h5>Significado de <code class="code-js">package.json</code>:</h5>
						<ul>
							<li><strong>name:</strong> Nombre del proyecto (<em>fundametos-desarrollo-Web</em>).</li>
							<li><strong>version:</strong> Versión actual del proyecto (<em>1.0.0</em>).</li>
							<li><strong>description:</strong> Breve descripción del proyecto.</li>
							<li><strong>scripts:</strong>
								<ul>
									<li><code style="color: white">test:jasmine</code>: Ejecuta las pruebas de Jasmine.
									</li>
									<li><code style="color: white">test:jest</code>: Ejecuta las pruebas de Jest.</li>
									<li><code style="color: white">test</code>: Ejecuta las pruebas de Jasmine y Jest en
										secuencia.</li>
								</ul>
							</li>
							<li><strong>devDependencies:</strong> Dependencias necesarias para el desarrollo del
								proyecto:
								<ul>
									<li><code style="color: white">jasmine</code>: Framework para pruebas unitarias.
									</li>
									<li><code style="color: white">jest</code>: Otro framework para pruebas unitarias.
									</li>
								</ul>
							</li>
							<li><strong>type:</strong> Especifica que el proyecto utiliza módulos ES6.</li>
						</ul>
						<p>Con esta configuración, puedes ejecutar:</p>
						<ul>
							<li><code class="code-js">npm run test:jasmine</code>: Para ejecutar las pruebas únicamente
								con Jasmine.</li>
							<li><code class="code-js">npm run test:jest</code>: Para ejecutar las pruebas únicamente con
								Jest.</li>
							<li><code class="code-js">npm run test</code>: Para ejecutar todas las pruebas en conjunto.
							</li>
						</ul>
						<hr>
						<h3>Configuración de Jest con Babel</h3>
						<p>Para que Jest pueda interpretar y ejecutar código JavaScript moderno (como ES Modules con
							<code class="code-js">import/export</code>), es necesario configurarlo con Babel. Babel
							transpila la
							sintaxis moderna a una compatible con Node.js.
						</p>

						<h4>¿Por qué es necesario Babel?</h4>
						<ul>
							<li>El entorno predeterminado de Node.js no soporta módulos ES6 de forma completa sin
								configuración adicional.</li>
							<li>Jest, por defecto, utiliza CommonJS (<code
									class="code-js">require/module.exports</code>), lo cual causa
								problemas al usar ES6 (<code class="code-js">import/export</code>).</li>
							<li>Babel permite transpilar el código moderno para garantizar compatibilidad con Jest.</li>
						</ul>

						<h4>Pasos para configurar Jest con Babel</h4>
						<ol>
							<li><strong>Instala las dependencias necesarias:</strong></li>
							<pre><code class="code-js">npm install --save-dev jest babel-jest @babel/core @babel/preset-env</code></pre>

							<li><strong>Crea un archivo de configuración de Babel:</strong></li>
							<p>En la raíz del proyecto, crea un archivo llamado <code
									class="code-js">babel.config.json</code> y agrega
								lo siguiente:</p>
							<pre><code class="code-js">{
"presets": ["@babel/preset-env"]
}</code></pre>

							<li><strong>Crea un archivo de configuración de Jest:</strong></li>
							<p>En la raíz del proyecto, crea un archivo llamado <code
									class="code-js">jest.config.js</code> y agrega lo
								siguiente:</p>
							<pre><code class="code-js">export default {
transform: {
	"^.+\\.js$": "babel-jest"
}
};</code></pre>

							<li><strong>Asegúrate de que <code class="code-js">package.json</code> esté configurado
									correctamente:</strong></li>
							<p>Asegúrate de incluir <code class="code-js">"type": "module"</code> si estás utilizando
								módulos ES6:</p>
							<pre><code class="code-js">{
"name": "fundametos-de-desarrollo-Web",
	"version": "1.0.0",
	"description": "Pruebas unitarias con Jest y Jasmine para ejemplos del proyecto",
	<mark>"type": "module",</mark>
	"scripts": {
	"test:jasmine": "jasmine",
	"test:jest": "jest",
	"test": "npm run test:jasmine && npm run test:jest"
	},
	"devDependencies": {
	"jest": "^29.7.0",
	"babel-jest": "^29.7.0",
	"@babel/core": "^7.21.0",
	"@babel/preset-env": "^7.21.0"
	}
}</code></pre>

							<li><strong>Ejecuta las pruebas:</strong></li>
							<p>Finalmente, puedes ejecutar tus pruebas con el siguiente comando:</p>
							<pre><code class="code-js">npm run test</code></pre>
						</ol>

						<p>Configurar Jest con Babel es fundamental para trabajar con sintaxis moderna de JavaScript en
							proyectos que utilicen ES Modules. La integración de Babel asegura que el código sea
							compatible con Jest y que las pruebas se ejecuten sin problemas.</p>
						<h4>Estructura del Proyecto</h4>
						<pre><code style="color: white">├── tests/
│   ├── jasmine/
│   │   └── example.spec.js
│   ├── jest/
│   │   └── example.test.js
├── package.json
├── babel.config.json
├── jest.config.json
├── app.js</code></pre>

						<h5>Descripción de la Estructura</h5>
						<ul>
							<li><strong>tests/jasmine/</strong>: Carpeta que contiene los archivos de pruebas
								específicas para Jasmine. Por ejemplo, <code class="code-js">example.spec.js</code>.
							</li>
							<li><strong>tests/jest/</strong>: Carpeta que contiene los archivos de pruebas específicas
								para Jest. Por ejemplo, <code class="code-js">example.test.js</code>.</li>
							<li><strong>package.json:</strong> Archivo de configuración del proyecto.</li>
							<li><strong>app.js:</strong> Archivo principal del proyecto.</li>
						</ul>
					</section>
					<hr class="non-js">

					<section id="jest">
						<h2>Pruebas unitarias: Ejemplo de configuración con Jest</h2>
						<p>En tu archivo package.json, agrega un script para ejecutar Jest:</p>
						<pre><code class="code-js">"scripts": { "test": "jest" }</code></pre>

						<h3>Ejecutar las pruebas</h3>
						<p>
							Ejecuta <code class="code-js">npm run test</code> en la terminal para ejecutar las pruebas.
							Jest
							buscará archivos con el sufijo <code class="code-js">.test.js</code> y ejecutará las
							pruebas
							definidas en ellos.
						</p>

						<h3>Conceptos clave de Jest</h3>
						<ul>
							<li><strong>describe:</strong> Agrupa pruebas relacionadas.</li>
							<li><strong>it (o test):</strong> Define una prueba individual.</li>
							<li><strong>expect:</strong> Crea una afirmación para verificar un valor.</li>
							<li><strong>toBe:</strong> Verifica igualdad estricta.</li>
							<li><strong>toEqual:</strong> Verifica igualdad profunda para objetos y arrays.</li>
							<li><strong>beforeEach y afterEach:</strong> Ejecutan código antes y después de cada
								prueba.
							</li>
							<li><strong>beforeAll y afterAll:</strong> Ejecutan código antes y después de todas las
								pruebas.</li>
							<li>Los spies, en Jest, se hace con métodos como <strong>jest.spyOn() o jest.fn().</strong>
							</li>
						</ul>

						<h3>Ejemplo con <code class="code-js">describe</code> y <code class="code-js">toEqual</code>
						</h3>
						<p>Imagina que tu código a evaluar es una suma:</p>
						<pre><code class="code-js">export const sum = (x, y) => x + y;</code></pre>
						<p>Su prueba con jest podría quedar algo así:</p>
						<pre>
<code class="code-js">// sum.test.js
import sum from './js/sum.js';

describe('sum function', () => {
  it('adds two numbers', () => {
    expect(sum(1, 2)).toBe(3);
  });

  it('handles negative numbers', () => {
    expect(sum(-1, 5)).toBe(4);
  });

  it('handles objects', () => {
    expect(sum({ a: 1 }, { b: 2 })).toEqual({ a: 1, b: 2 });
  });
});</code>
  </pre>
						<p>Podrías utilizar el archivo <code class="code-js">Funciones.js</code> para hacer una prueba a
							la función <code class="code-js">ejecutarFuncionComoParametro</code> para hacer las pruebas
							unitarias
							necesarias. Ejecuta <code class="code-js">npm run test</code> o <code
								class="code-js">npm run test:jest</code> en
							la terminal para ejecutar las pruebas con jest.</p>
						<p>
							<strong>¿Qué hace la función?</strong>
						</p>
						<ol>
							<li>
								<strong>La función <code class="code-js">sum</code> toma dos argumentos y devuelve
									su suma.</strong>
							</li>
							<li>prueba con describe y toEqual:</li>
							<ul>
								<li><code class="code-js">describe</code> agrupa las pruebas relacionadas con la
									función
									sum.</li>
								<li><code class="code-js">it</code> define casos de prueba individuales.</li>
								<li><code class="code-js">toBe</code> verifica la igualdad estricta para valores
									primitivos.</li>
								<li><code class="code-js">toEqual</code> verifica la igualdad profunda para objetos.
								</li>
							</ul>
							</li>
						</ol>

						<h3>Pruebas asíncronas con jest</h3>
						<p>
							Para probar código asíncrono, como promesas o callbacks, Jest proporciona varias
							herramientas:
						</p>
						<ul>
							<li><strong>async/await:</strong> La forma más moderna y legible de probar código
								asíncrono.
							</li>
							<li><strong>done:</strong> Una función de callback que indica que una prueba asíncrona
								ha
								finalizado.</li>
							<li><strong>resolves y rejects:</strong> Afirmaciones para promesas.</li>
						</ul>

						<h3>Ejemplo con <code class="code-js">async/await</code> sustituyendo <code
								class="code-js">done</code></h3>
						<p>Código a evaluar:</p>
						<pre>
<code class="code-js">// fetchData.js
export async function fetchData(url) {
  const response = await fetch(url);
  return response.json();
}</code></pre>
						<p>Prueba en <code style="color: white;">test/jest/fetchData.test.js</code></p>
						<pre><code class="code-js">// fetchData.test.js
import fetchData from './js/fetchData';

test('fetches data from an API', async () => {
  const data = await fetchData('https://jsonplaceholder.typicode.com/todos/1');
  expect(data.userId).toBe(1);
  expect(data.id).toBe(1);
});</code></pre>
						<p>Puedes crear el archivo fetchData.js y su respectiva prueba fetchData.test.js, con Ctrl + ñ
							puedes abrir la terminal en VSCode ejecutarla con <code class="code-js">npm run test</code>
							o <code class="code-js">npm run test:jest</code>.</p>
						<p>
							<strong>¿Qué hace la función?</strong>
						</p>
						<ol>
							<li>
								<strong>La función <code class="code-js">fetchData</code> realiza una petición HTTP a
									una API y devuelve los datos en formato JSON.</strong>
							<li>La prueba con async/await:</li>
							<ul>
								<li><code class="code-js">async/await</code> simplifica la escritura de pruebas para
									código asíncrono.</li>
								<li>La prueba espera a que la petición a la API se complete y luego verifica los datos
									recibidos.</li>
								<li><code class="code-js">expect(data.userId).toBe(1);</code> evalua la prueba con la
									expectativa de que el JSON convertido en objeto JavaScript contenga la propiedad
									userId === 1 de forma estricta por lo que no convierte el texto en número</li>
								<li>Me parece importante mencionar que done también es compatible con Jest en caso de
									trabajar con callbacks.</li>
								<ul>
									<li>En pruebas con Jasmine o Jest, done se usa cuando trabajas con operaciones que
										dependen del Event Loop pero no están basadas en promesas, como:
										<ul>
											<li>Eventos del DOM.</li>
											<li>setTimeout o setInterval.</li>
										</ul>
									<li>Con done, puedes señalar manualmente cuándo debe concluir la prueba al llamar a
										done() después de que la operación se complete, asegurándote de que el Event
										Loop haya manejado todas las tareas relevantes.</li>
								</ul>
							</ul>
						</ol>

						<hr>
						<h3>Ejemplo de Pruebas Unitarias con <code class="code-js">describe</code> y <code
								class="code-js">expect</code> en Jest</h3>
						<p>
							En el siguiente ejemplo probaremos el funcionamiento de <code
								class="code-js">ejecutarEjemploPOO</code> en <code class="code-js">EjemploPoo.js</code>
							junto a sus dependencias en un entorno de POO utilizando Jest. Se realizan mocks de las
							clases y módulos necesarios (como <code class="code-js">Vehiculo</code>, <code
								class="code-js">Coche</code>, <code class="code-js">Moto</code> y <code
								class="code-js">Utils</code>) para poder verificar que:
						</p>
						<ol>
							<li>Maneje correctamente el error al intentar instanciar la clase abstracta <code
									class="code-js">Vehiculo</code>.</li>
							<li>Se cree un coche y se llamen a sus métodos (<code class="code-js">arrancar</code>, <code
									class="code-js">frenar</code> y <code class="code-js">convertir</code>).</li>
							<li>Se cree una moto y se llamen a sus métodos (<code class="code-js">arrancar</code> y
								<code class="code-js">frenar</code>).
							</li>
							<li>Se muestre el código generado dinámicamente mediante <code
									class="code-js">Utils.mostrarCodigo</code>.</li>
						</ol>
						<h4>Código a evaluar de <code class="code-js">(js/POO/EjemploPOO.js):</code></h4>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">//importaciones se suelen hacer al principio del documento

	import Vehiculo from './Vehiculo.js';
	import Coche from './Coche.js';
	import Moto from './Moto.js';
	import Utils from '../utils.js';
	
	export default function ejecutarEjemploPOO(){
	try {
		const miVehiculo = new Vehiculo('Genérico', 'Modelo'); // Error: No se puede instanciar una clase abstracta Vehiculo.
	} catch (error) {
		Utils.mostrarResultado('resultado-ejemplo-poo', error.message);
	}
	
	const miCoche = new Coche('Toyota', 'Corolla');
	miCoche.arrancar(); // El coche Toyota Corolla está arrancando.
	miCoche.frenar(); // El coche Toyota Corolla está frenando.
	miCoche.convertir(); // El coche Toyota Corolla se está convirtiendo.
	
	const miMoto = new Moto('Yamaha', 'MT-07');
	miMoto.arrancar(); // La moto Yamaha MT-07 está arrancando.
	miMoto.frenar(); // La moto Yamaha MT-07 está frenando.
	
	// Mostrar código dinámicamente con utils.js ahora que sabemos module.exports y require
	const codigo= `
	======== ARCHIVO interfaces.js ========
	
	// Definición de las "interfaces"
	export const Arrancable = {
		arrancar: function() {
			throw new Error("Método 'arrancar()' debe ser implementado.");
		}
	};
	
	export const Frenable = {
		frenar: function() {
			throw new Error("Método 'frenar()' debe ser implementado.");
		}
	};
	
	export const Convertible = {
		convertir: function() {
			throw new Error("Método 'convertir()' debe ser implementado.");
		}
	};
	
	
	======== ARCHIVO Vehiculo.js ========
	
	export default class Vehiculo {
		constructor(marca, modelo) {
			if (this.constructor === Vehiculo) {
				throw new Error("No se puede instanciar una clase abstracta Vehiculo.");
			}
			this.marca = marca;
			this.modelo = modelo;
		}
	
		verificarImplementacion(interfaces) {
			interfaces.forEach(interfaz => {
				for (let method in interfaz) {
					if (typeof this[method] !== 'function') {
						throw new Error(\`La clase \${this.constructor.name} debe implementar el método \${method}\`);
					}
				}
			});
		}
	}
	
	======== ARCHIVO Coche.js ========
	
	import Vehiculo from './Vehiculo.js';
	import { Arrancable, Frenable, Convertible } from './interfaces/interfaces.js';
	import Utils from '../utils.js';
	
	export default class Coche extends Vehiculo {
		constructor(marca, modelo) {
			super(marca, modelo);
			this.verificarImplementacion([Arrancable, Frenable, Convertible]);
		}
	
		arrancar() {
			Utils.mostrarResultado('resultado-ejemplo-poo', \`El coche \${this.marca} \${this.modelo} está arrancando.\`);
		}
	
		frenar() {
			Utils.mostrarResultado('resultado-ejemplo-poo', \`El coche \${this.marca} \${this.modelo} está frenando.\`);
		}
	
		convertir() {
			Utils.mostrarResultado('resultado-ejemplo-poo', \`El coche \${this.marca} \${this.modelo} se está convirtiendo.\`);
		}
	}
	
	======== ARCHIVO Moto.js =========
	
	import Vehiculo from './Vehiculo.js';
	import { Arrancable, Frenable } from './interfaces/interfaces.js';
	import Utils from '../utils.js';
	
	export default class Moto extends Vehiculo {
		constructor(marca, modelo) {
			super(marca, modelo);
			this.verificarImplementacion([Arrancable, Frenable]);
		}
	
		arrancar() {
			Utils.mostrarResultado('resultado-ejemplo-poo', \`La moto \${this.marca} \${this.modelo} está arrancando.\`);
		}
	
		frenar() {
			Utils.mostrarResultado('resultado-ejemplo-poo', \`La moto \${this.marca} \${this.modelo} está frenando.\`);
		}
	}
	\
	
	
	======== ARCHIVO EjemploPOO.js ========
	
	import Coche from './Coche.js';
	import Moto from './Moto.js';
	import Utils from '../utils.js';
	
	export default function ejecutarEjemploPOO(){
	try {
		const miVehiculo = new Vehiculo('Genérico', 'Modelo'); // Error: No se puede instanciar una clase abstracta Vehiculo.
	} catch (error) {
		Utils.mostrarResultado('resultado-ejemplo-poo', error.message);
	}
	
	const miCoche = new Coche('Toyota', 'Corolla');
	miCoche.arrancar(); // El coche Toyota Corolla está arrancando.
	miCoche.frenar(); // El coche Toyota Corolla está frenando.
	miCoche.convertir(); // El coche Toyota Corolla se está convirtiendo.
	
	const miMoto = new Moto('Yamaha', 'MT-07');
	miMoto.arrancar(); // La moto Yamaha MT-07 está arrancando.
	miMoto.frenar(); // La moto Yamaha MT-07 está frenando.
	`;
	Utils.mostrarCodigo('code-ejemplo-poo-mostrar',codigo);
	}</code></pre>
						<h4>Código de Prueba (test/jest/EjemploPOO.test.js):</h4>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">// Importación de módulos
import ejecutarEjemploPOO from '../../js/POO/EjemploPOO.js';
import Coche from '../../js/POO/Coche.js';
import Moto from '../../js/POO/Moto.js';
import Utils from '../../js/utils.js';

// Mock de la clase abstracta Vehiculo
jest.mock('../../js/POO/Vehiculo.js', () => {
return jest.fn().mockImplementation(() => {
	throw new Error("No se puede instanciar una clase abstracta Vehiculo.");
});
});

// Mock de la clase Coche
jest.mock('../../js/POO/Coche.js', () => {
return jest.fn().mockImplementation((marca, modelo) => {
	return {
	arrancar: jest.fn(() => `El coche ${marca} ${modelo} está arrancando.`),
	frenar: jest.fn(() => `El coche ${marca} ${modelo} está frenando.`),
	convertir: jest.fn(() => `El coche ${marca} ${modelo} se está convirtiendo.`)
	};
});
});

// Mock de la clase Moto
jest.mock('../../js/POO/Moto.js', () => {
return jest.fn().mockImplementation((marca, modelo) => {
	return {
	arrancar: jest.fn(() => `La moto ${marca} ${modelo} está arrancando.`),
	frenar: jest.fn(() => `La moto ${marca} ${modelo} está frenando.`)
	};
});
});

// Mock de Utils
jest.mock('../../js/utils.js', () => ({
mostrarResultado: jest.fn(),
mostrarCodigo: jest.fn()
}));

describe('ejecutarEjemploPOO', () => {
it('debería manejar el error al intentar instanciar la clase Vehiculo', () => {
	ejecutarEjemploPOO();
	expect(Utils.mostrarResultado).toHaveBeenCalledWith('resultado-ejemplo-poo', "No se puede instanciar una clase abstracta Vehiculo.");
});

it('debería crear un coche y llamar a sus métodos', () => {
	ejecutarEjemploPOO();
	expect(Coche).toHaveBeenCalledWith('Toyota', 'Corolla');
	const cocheMockInstance = Coche.mock.results[0].value;
	expect(cocheMockInstance.arrancar).toHaveBeenCalled();
	expect(cocheMockInstance.frenar).toHaveBeenCalled();
	expect(cocheMockInstance.convertir).toHaveBeenCalled();
});

it('debería crear una moto y llamar a sus métodos', () => {
	ejecutarEjemploPOO();
	expect(Moto).toHaveBeenCalledWith('Yamaha', 'MT-07');
	const motoMockInstance = Moto.mock.results[0].value;
	expect(motoMockInstance.arrancar).toHaveBeenCalled();
	expect(motoMockInstance.frenar).toHaveBeenCalled();
});

it('debería mostrar el código generado dinámicamente', () => {
	ejecutarEjemploPOO();
	expect(Utils.mostrarCodigo).toHaveBeenCalledWith(
	'code-ejemplo-poo-mostrar',
	expect.stringContaining('======== ARCHIVO interfaces.js ========')
	);
});
});</code></pre>

						<p>Para ejecutar las pruebas, abre la terminal y ejecuta:</p>
						<pre><code class="code-js">npm run test:jest</code></pre>
						<p>
							<strong>¿Qué hace la prueba?</strong>
						</p>
						<ol>
							<li>
								<strong>Simula el comportamiento de clases y métodos utilizando mocks:</strong>
								La prueba utiliza <code class="code-js">jest.mock</code> para simular la funcionalidad
								de clases como <code class="code-js">Vehiculo</code>, <code
									class="code-js">Coche</code>, y <code class="code-js">Moto</code>, así como métodos
								de utilidades (<code class="code-js">Utils</code>). Esto permite comprobar cómo
								interactúa la función <code class="code-js">ejecutarEjemploPOO</code> con estas clases y
								métodos sin depender de implementaciones reales.
							</li>
							<li>
								<strong>Maneja errores:</strong>
								La prueba verifica que al intentar instanciar la clase abstracta <code
									class="code-js">Vehiculo</code>, se maneje correctamente el error y se llame a <code
									class="code-js">Utils.mostrarResultado</code> con el mensaje: <code
									class="code-js">"No se puede instanciar una clase abstracta Vehiculo."</code>.
							</li>
							<li>
								<strong>Comprueba la creación y uso de objetos:</strong>
								Evalúa que <code class="code-js">ejecutarEjemploPOO</code> instancie correctamente las
								clases <code class="code-js">Coche</code> y <code class="code-js">Moto</code>, llamando
								a sus respectivos métodos (<code class="code-js">arrancar</code>, <code
									class="code-js">frenar</code>, y <code class="code-js">convertir</code>).
							</li>
							<li>
								<strong>Valida la generación de código dinámico:</strong>
								La prueba verifica que se llame a <code class="code-js">Utils.mostrarCodigo</code> con
								el código generado dinámicamente, incluyendo el archivo <code
									class="code-js">interfaces.js</code>, lo que demuestra que la función maneja
								adecuadamente la visualización de código.
							</li>
							<li>
								<strong>Organiza las pruebas en bloques:</strong>
								Cada bloque <code class="code-js">it</code> verifica un aspecto específico del
								comportamiento de la función <code class="code-js">ejecutarEjemploPOO</code>:
								<ul>
									<li><code
											class="code-js">it('debería manejar el error al intentar instanciar la clase Vehiculo')</code>:
										Evalúa la correcta gestión de errores.</li>
									<li><code
											class="code-js">it('debería crear un coche y llamar a sus métodos')</code>:
										Comprueba la creación y uso de un objeto coche.</li>
									<li><code
											class="code-js">it('debería crear una moto y llamar a sus métodos')</code>:
										Valida la creación y uso de un objeto moto.</li>
									<li><code
											class="code-js">it('debería mostrar el código generado dinámicamente')</code>:
										Asegura que el código dinámico se muestre correctamente.</li>
								</ul>
							</li>
						</ol>
						<p>
							Estas pruebas garantizan que <code class="code-js">ejecutarEjemploPOO</code> funcione
							correctamente en diferentes escenarios: manejo de errores, creación de objetos, y generación
							de código. Se utilizan <code class="code-js">jest.mock</code> para simular el comportamiento
							de clases y métodos, y <code class="code-js">Utils.mostrarResultado</code> y <code
								class="code-js">Utils.mostrarCodigo</code> para validar que los resultados y el código
							se muestran correctamente.
						</p>

						<h4>Salida al ejecutar los tests:</h4>
						<div class="output">
							<pre><code class="code-js">> fundametos-de-desarrollo-web@1.0.0 test:jest
> jest

PASS  test/jest/EjemploPOO.test.js
ejecutarEjemploPOO
	√ debería manejar el error al intentar instanciar la clase Vehiculo (14 ms)
	√ debería crear un coche y llamar a sus métodos (2 ms)
	√ debería crear una moto y llamar a sus métodos (1 ms)
	√ debería mostrar el código generado dinámicamente (1 ms)

Test Suites: 1 passed, 1 total
Tests:       4 passed, 4 total
Snapshots:   0 total
Time:        1.698 s
Ran all test suites.</code></pre>
						</div>

						<p>
							Este ejemplo muestra cómo se pueden utilizar <code class="code-js">jest.mock</code> para
							simular dependencias y verificar que las funciones se comporten de forma correcta sin
							necesidad de instanciar clases abstractas o realizar llamadas reales a los métodos.
						</p>
						<hr>
						<h3>Integración de JSDOM para pruebas con el DOM</h3>
						<p>Por defecto Jest utiliza el entorno Node para ejecutar las pruebas, y este entorno no tiene
							acceso al objeto document, que es específico del navegador. Para resolver esto, necesitas
							configurar Jest para que use el entorno JSDOM, que simula el DOM del navegador.</p>
						<p>Asegúrate de configurar Jest para que utilice <code class="code-js">jsdom</code> como su
							entorno de pruebas. La configuración de Jest ya
							utiliza JSDOM de manera predeterminada, pero para asegurarte de que está configurado
							correctamente, agrega el archivo de configuración jest.config.js (si no lo tienes).</p>
						<pre><code class="code-js">export default {
<mark>testEnvironment: "jest-environment-jsdom",</mark>
transform: {
	"^.+\\.js$": "babel-jest"
}
};
</code></pre>
						<p>Instalar JSDOM manualmente (si es necesario) Aunque Jest incluye JSDOM por defecto, si por
							alguna razón no está instalado correctamente, puedes agregarlo manualmente con:</p>
						<pre><code class="code-js">npm install --save-dev jest-environment-jsdom</code></pre>
						<hr>
						<h3>Ejemplo de Pruebas Unitarias con <code class="code-js">describe</code> y <code
								class="code-js">expect</code> en Jest para <code class="code-js">Arrays.test.js</code>
						</h3>
						<p>
							En este ejemplo se realizan pruebas unitarias para validar el correcto funcionamiento de
							operaciones sobre arrays, utilizando Jest y el entorno <code
								class="code-js">jest-environment-jsdom</code> para simular el DOM cuando sea necesario.
							Se utiliza <code class="code-js">babel-jest</code> para transformar los archivos JavaScript.
						</p>
						<p>
							La configuración de Jest se define en un archivo de configuración (por ejemplo, <code
								class="code-js">jest.config.js</code>) de la siguiente manera:
						</p>
						<pre>
<code class="code-js">export default {
testEnvironment: "jest-environment-jsdom",
setupFiles: ['&lt;rootDir&gt;/jest.setup.js'], //debemos crear este archivo
transform: {
  "^.+\\.js$": "babel-jest"
}
};</code>
</pre>
						<p>
							Para poder simular el comportamiento de utils.js que utilizamos para mostrarResultado y
							mostrarCodigo
							al cual le haremos sus pruebas a continuación, pero al ser una dependencia en Arrays.js se
							simula con JSDOM que requiere <code class="code-js">TextEncoder</code> y <code
								class="code-js">TextDecoder</code> de node, por lo que debemos crear (<code
								class="code-js">jest.setup.js</code>) como lo acabamos de especificar en <code
								class="code-js">jest.config.js</code> en la propiedad <code
								class="code-js">setupFiles</code> quedando <code class="code-js">jest.setup.js</code> de
							la siguiente forma:
						</p>
						<pre>
<code class="code-js">import { TextEncoder, TextDecoder } from 'util';

	global.TextEncoder = TextEncoder;
	global.TextDecoder = TextDecoder;
	</code>
</pre>
						<p>
							Esta configuración le indica a Jest que:
						</p>
						<ol>
							<li>
								Use <code class="code-js">jest-environment-jsdom</code> como entorno de pruebas, lo que
								permite simular el objeto <code class="code-js">document</code> y otros elementos del
								DOM.
							</li>
							<li>
								Utilice <code class="code-js">babel-jest</code> para transformar los archivos
								JavaScript, facilitando la compatibilidad con la sintaxis moderna.
							</li>
						</ol>
						<h4>Código a evaluar de (Arrays.js):</h4>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">import Utils from './utils.js';
const idResultado = 'resultado-ejemplo-arrays';
const idCode = 'code-ejemplo-arrays-mostrar';

// Push
function ejecutarPush() {
	const array = [1, 2, 3];
	const elementoAAgregar =document.getElementById("input-push").value;
	if (elementoAAgregar){
		array.push(elementoAAgregar); //agrega al final
	}else {
		Utils.mostrarResultado(idResultado, `No agregaste nada, se agregará un 4`);
		array.push(4);
	}
	
	const codigo = `const array = [1, 2, 3];
	const elementoAAgregar =document.getElementById("input-push").value;
	if (elementoAAgregar){
		array.push(elementoAAgregar);
	}else {
		Utils.mostrarResultado(idResultado, \`No agregaste nada, se agregará un 4\`);
		array.push(4);
	}`;

	Utils.mostrarResultado(idResultado, `Array después de push: ${array}`);
	Utils.mostrarCodigo(idCode, codigo);
}

// Pop
function ejecutarPop() {
	const array = [1, 2, 3];
	const elementoExtraido = array.pop(); //último elemento

	const codigo = `const array = [1, 2, 3];
const elementoExtraido = array.pop(); // elementoExtraido es 3, array es [1, 2]`;

	Utils.mostrarResultado(idResultado, `Elemento eliminado: ${elementoExtraido}, Array restante: ${array}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//Unshift
function ejecutarUnshift() {
	const array = [2, 3];
	const elementoAAgregar =document.getElementById("input-unshift").value;
	if (elementoAAgregar){
		array.unshift(elementoAAgregar); //agrega al principio
	}else {
		Utils.mostrarResultado(idResultado, `No agregaste nada, se agregará un 1`);
		array.unshift(1); //agrega al principio
	}
	const codigo = `const array = [2, 3];
	const elementoAAgregar =document.getElementById("input-unshift").value;
	if (elementoAAgregar){
		array.unshift(elementoAAgregar); //agrega al principio
	}else {
		Utils.mostrarResultado(idResultado, 'No agregaste nada, se agregará un 1');
		array.unshift(1); //agrega al principio
	}`;

	Utils.mostrarResultado(idResultado, `Array después de unshift: ${array}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//shift
function ejecutarShift() {
	const array = [1, 2, 3];
	const elementoExtraido = array.shift(); // último elemento

	const codigo = `const array = [1, 2, 3];
const elementoExtraido = array.shift(); // elementoExtraido es 1, array es [2, 3]`;

	Utils.mostrarResultado(idResultado, `Elemento eliminado: ${elementoExtraido}, Array restante: ${array}`);
	Utils.mostrarCodigo(idCode, codigo);
}

function ejecutarConcat() {
	const array1 = [1, 2];
	const array2 = [3, 4];
	const result = array1.concat(array2);

	const codigo = `const array1 = [1, 2];
const array2 = [3, 4];
const result = array1.concat(array2); // result es [1, 2, 3, 4]`;

	Utils.mostrarResultado(idResultado, `Array concatenado: ${result}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//Sort
function ejecutarSort() {
	const array = [3, 1, 4, 2];
	array.sort(); //ordena ascendentemente o alfabéticamente

	const codigo = `const array = [3, 1, 4, 2];
array.sort(); // Ahora array es [1, 2, 3, 4]`;

	Utils.mostrarResultado(idResultado, `Array ordenado: ${array}`);
	Utils.mostrarCodigo(idCode, codigo);
}

// Slice
function ejecutarSlice() {
	const array = [1, 2, 3, 4];
	const cortado = array.slice(1, 3); //(inicio incluido, final no incluido) para poder utilizar .length

	const codigo = `const array = [1, 2, 3, 4]; 
const cortado = array.slice(1, 3); // cortado es [2, 3]
//(inicio incluido, final no incluido) para poder utilizar .length`;

	Utils.mostrarResultado(idResultado, `Resultado de slice: ${cortado}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//Reverse
function ejecutarReverse() {
	const array = [1, 2, 3];
	array.reverse(); // Ahora array es [3, 2, 1]
	const nombres =["Ricardo", "Willy", "Patricio","Bob", "Alan", "Francisco"]
	nombres.sort(); //ordenado alfabéticamente A - Z
	nombres.reverse(); //ordenado de Z - A
	

	const codigo = `const array = [1, 2, 3];
	array.reverse(); // Ahora array es [3, 2, 1]
	const nombres =["Ricardo", "Willy", "Patricio","Bob", "Alan", "Francisco"]
	nombres.sort(); //ordenado alfabéticamente A - Z
	nombres.reverse(); //ordenado de Z - A`;

	Utils.mostrarResultado(idResultado, `Array invertido: ${array}\nNombres de Z - A: ${nombres}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//Flat
function ejecutarFlat() {
	const array = [1, [2, [3, [4]]]];
	const aplanado = array.flat(3);

	const codigo = `const array = [1, [2, [3, [4]]]];
const aplanado = array.flat(3); // aplanado es [1, 2, 3, 4]`;

	Utils.mostrarResultado(idResultado, `Array aplanado: ${aplanado}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//Includes
function ejecutarIncludes() {
	const array = [1, 2, 3, 4, "Ricardo", "Willy", "Patricio", "Bob", "Alan", "Francisco"];
	let elementoBuscado = document.getElementById("input-includes").value;
	let hasValue = false;

	if (elementoBuscado) {
		elementoBuscado = isNaN(elementoBuscado) ? elementoBuscado : Number(elementoBuscado);
		hasValue = array.includes(elementoBuscado);
	} else {
		Utils.mostrarResultado(idResultado, "No buscaste nada, se buscará Ricardo");
		elementoBuscado = "Ricardo";
		hasValue = array.includes(elementoBuscado);
	}

	const codigo = `const array = [1, 2, 3, 4, "Ricardo", "Willy", "Patricio", "Bob", "Alan", "Francisco"];
const elementoBuscado = document.getElementById("input-includes").value;
let hasValue = false;

if (elementoBuscado) {
	elementoBuscado = isNaN(elementoBuscado) ? elementoBuscado : Number(elementoBuscado);
	hasValue = array.includes(elementoBuscado);
} else {
	Utils.mostrarResultado(idResultado, "No buscaste nada, se buscará Ricardo");
	elementoBuscado = "Ricardo";
	hasValue = array.includes(elementoBuscado);
}`;

	Utils.mostrarResultado(idResultado, `¿Contiene el valor ${elementoBuscado}?: ${hasValue}`);
	Utils.mostrarCodigo(idCode, codigo);

	/* Bien por ver esto curioso! 
	Cómo utilizar includes sin que distinga mayusculas y minusculas?
	Todavía no sabemos programación funcional
	pero se podría utilizar map para volverlas toUperCase = mayusculas
	toLowerCase =minusculas y comparar en igualdad:
	
	elementoBuscado = isNaN(elementoBuscado) ? elementoBuscado.toLowerCase() : Number(elementoBuscado);
	hasValue = array.map(item => typeof item === 'string' ? item.toLowerCase() : item).includes(elementoBuscado);*/
}

// IndexOf
function ejecutarIndexOf() {
	const array = [1, 2, 3];
	const index = array.indexOf(2);

	const codigo = `const array = [1, 2, 3];
const index = array.indexOf(2); // index es 1`;

	Utils.mostrarResultado(idResultado, `Índice del valor 2: ${index}`);
	Utils.mostrarCodigo(idCode, codigo);
}

//LastIndexOf
function ejecutarLastIndexOf() {
	const array = [1, 2, 3, 2];
	const index = array.lastIndexOf(2);

	const codigo = `const array = [1, 2, 3, 2];
const index = array.lastIndexOf(2); // index es 3`;

	Utils.mostrarResultado(idResultado, `Último índice del valor 2: ${index}`);
	Utils.mostrarCodigo(idCode, codigo);
}

// Length
function ejecutarLength() {
	const array = [1, 2, 3];
	const length = array.length;

	const codigo = `const array = [1, 2, 3];
const length = array.length; // length es 3`;

	Utils.mostrarResultado(idResultado, `Longitud del array: ${length}`);
	Utils.mostrarCodigo(idCode, codigo);
}

export {
	ejecutarPush,
	ejecutarPop,
	ejecutarShift,
	ejecutarUnshift,
	ejecutarConcat,
	ejecutarSort,
	ejecutarSlice,
	ejecutarReverse,
	ejecutarFlat,
	ejecutarIncludes,
	ejecutarIndexOf,
	ejecutarLastIndexOf,
	ejecutarLength
};</code></pre>
						<h4>Código de Prueba (Arrays.test.js):</h4>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">// Simulación del DOM con JSDOM
import { JSDOM } from 'jsdom';
const dom = new JSDOM(`
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
		&lt;body&gt;
			&lt;div id="resultado-ejemplo-arrays"&gt;&lt;/div&gt;
			&lt;div id="code-ejemplo-arrays-mostrar"&gt;&lt;/div&gt;
		&lt;/body&gt;
	&lt;/html&gt;
`);
global.document = dom.window.document;


// Polifill para TextEncoder y TextDecoder en Node
import { TextEncoder, TextDecoder } from 'util';
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;



// Importación de módulos
import * as Arrays from '../../js/Arrays.js';
import Utils from '../../js/utils.js';


describe('Pruebas de funciones de Arrays.js', () => {
	let mostrarResultadoSpy;

	beforeEach(() => {
	// Espiar la función mostrarResultado de Utils
	mostrarResultadoSpy = jest.spyOn(Utils, 'mostrarResultado').mockImplementation(() => { });

	//volvemos a colocar los ellementos de DOM para que no falle la proxoma prueba con Utils
	document.body.innerHTML = `
	&lt;div id="resultado-ejemplo-arrays"&gt;&lt;/div&gt;
	&lt;div id="code-ejemplo-arrays-mostrar"&gt;&lt;/div&gt;
	`;
	});

	afterEach(() => {
	jest.restoreAllMocks();
	// Limpiar inputs creados en el DOM si existen
	['input-push', 'input-unshift', 'input-includes'].forEach(id => {
		const elem = document.getElementById(id);
		if (elem) elem.remove();
	});
	//volvemos a colocar los ellementos de DOM para que no falle la proxoma prueba con Utils
	document.body.innerHTML = `
	&lt;div id="resultado-ejemplo-arrays"&gt;&lt;/div&gt;
	&lt;div id="code-ejemplo-arrays-mostrar"&gt;&lt;/div&gt;
	`;
	});

	// Tests para cada función
	describe('ejecutarPush', () => {
	it('debe agregar el valor ingresado al final del array', () => {
		const inputPush = document.createElement('input');
		inputPush.id = 'input-push';
		inputPush.value = '10';
		document.body.appendChild(inputPush);

		Arrays.ejecutarPush();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array después de push: 1,2,3,10'
		);

		inputPush.remove();
	});

	it('debe agregar el valor por defecto 4 cuando no se ingresa nada', () => {
		const inputPush = document.createElement('input');
		inputPush.id = 'input-push';
		inputPush.value = '';
		document.body.appendChild(inputPush);

		Arrays.ejecutarPush();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array después de push: 1,2,3,4'
		);

		inputPush.remove();
	});
	});

	describe('ejecutarPop', () => {
	it('debe eliminar el último elemento del array', () => {
		Arrays.ejecutarPop();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Elemento eliminado: 3, Array restante: 1,2'
		);
	});
	});

	describe('ejecutarUnshift', () => {
	it('debe agregar el valor ingresado al principio del array', () => {
		const inputUnshift = document.createElement('input');
		inputUnshift.id = 'input-unshift';
		inputUnshift.value = '0';
		document.body.appendChild(inputUnshift);

		Arrays.ejecutarUnshift();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array después de unshift: 0,2,3'
		);

		inputUnshift.remove();
	});

	it('debe agregar el valor por defecto 1 cuando no se ingresa nada', () => {
		const inputUnshift = document.createElement('input');
		inputUnshift.id = 'input-unshift';
		inputUnshift.value = '';
		document.body.appendChild(inputUnshift);

		Arrays.ejecutarUnshift();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array después de unshift: 1,2,3'
		);

		inputUnshift.remove();
	});
	});

	describe('ejecutarShift', () => {
	it('debe eliminar el primer elemento del array', () => {
		Arrays.ejecutarShift();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Elemento eliminado: 1, Array restante: 2,3'
		);
	});
	});

	describe('ejecutarConcat', () => {
	it('debe concatenar los dos arrays', () => {
		Arrays.ejecutarConcat();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array concatenado: 1,2,3,4'
		);
	});
	});

	describe('ejecutarSort', () => {
	it('debe ordenar el array de forma ascendente', () => {
		Arrays.ejecutarSort();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array ordenado: 1,2,3,4'
		);
	});
	});

	describe('ejecutarSlice', () => {
	it('debe extraer el segmento del array', () => {
		Arrays.ejecutarSlice();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Resultado de slice: 2,3'
		);
	});
	});

	describe('ejecutarReverse', () => {
	it('debe invertir el array y mostrar los nombres en orden Z-A', () => {
		Arrays.ejecutarReverse();

		const expectedResultado =
		'Array invertido: 3,2,1\nNombres de Z - A: Willy,Ricardo,Patricio,Francisco,Bob,Alan';

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		expectedResultado
		);
	});
	});

	describe('ejecutarFlat', () => {
	it('debe aplanar el array', () => {
		Arrays.ejecutarFlat();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Array aplanado: 1,2,3,4'
		);
	});
	});

	describe('ejecutarIncludes', () => {
	it('debe verificar que el array contenga el valor ingresado (string)', () => {
		const inputIncludes = document.createElement('input');
		inputIncludes.id = 'input-includes';
		inputIncludes.value = 'Patricio';
		document.body.appendChild(inputIncludes);

		Arrays.ejecutarIncludes();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'¿Contiene el valor Patricio?: true'
		);

		inputIncludes.remove();
	});

	it('debe buscar el valor por defecto "Ricardo" cuando no se ingresa nada', () => {
		const inputIncludes = document.createElement('input');
		inputIncludes.id = 'input-includes';
		inputIncludes.value = '';
		document.body.appendChild(inputIncludes);

		Arrays.ejecutarIncludes();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'¿Contiene el valor Ricardo?: true'
		);

		inputIncludes.remove();
	});
	});

	describe('ejecutarIndexOf', () => {
	it('debe retornar el índice del valor 2', () => {
		Arrays.ejecutarIndexOf();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Índice del valor 2: 1'
		);
	});
	});

	describe('ejecutarLastIndexOf', () => {
	it('debe retornar el último índice del valor 2', () => {
		Arrays.ejecutarLastIndexOf();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Último índice del valor 2: 3'
		);
	});
	});

	describe('ejecutarLength', () => {
	it('debe mostrar la longitud del array', () => {
		Arrays.ejecutarLength();

		expect(mostrarResultadoSpy).toHaveBeenLastCalledWith(
		'resultado-ejemplo-arrays',
		'Longitud del array: 3'
		);
	});
	});
});</code></pre>
						<p>
							Para ejecutar las pruebas, abre la terminal y ejecuta el siguiente comando:
						</p>
						<pre>
<code class="code-js">npm run test:jest</code>
</pre>
						<h4>Salida al ejecutar los tests:</h4>
						<div class="output">
							<pre>
<code class="code-js">> fundametos-de-desarrollo-web@1.0.0 test:jest
> jest

PASS  test/jest/EjemploPOO.test.js
PASS  test/jest/Arrays.test.js    

Test Suites: 2 passed, 2 total
Tests:       14 passed, 14 total
Snapshots:   0 total
Time:        18.326 s
Ran all test suites.</code>
  </pre>
						</div>
						<p>
							Este ejemplo muestra cómo, además de las pruebas sobre POO, se pueden realizar pruebas
							unitarias enfocadas en operaciones con arrays. Se utiliza la configuración de Jest para
							asegurar que el entorno simule un navegador mediante <code class="code-js">jsdom</code> y se
							transforma el código JavaScript moderno con <code class="code-js">babel-jest</code>.
						</p>
						<p>
							Con esta estructura, se puede comprobar que las funciones que manipulan arrays se comportan
							como se espera, validando tanto el contenido, la longitud y el filtrado de los elementos.
						</p>
						<hr>
						<section id="pruebaUtils">
							<h3>Pruebas a utils.js</h3>
							<p>Podemos hacerle las pruebas unitarias a <code class="code-js">utils.js</code> que sólo
								tiene dos métodos para mostrarResultado y mostrarCodigo.</p>
							<pre pre class="pre-largo" id="pre-ancho100"><code class="code-js">const Utils = {
mostrarResultado: function(idEtiqueta, resultado) {
	const textarea = document.getElementById(idEtiqueta);
	if (textarea) {
		textarea.value += resultado + "\n";
	} else {
		console.error(`Elemento con id "${idEtiqueta}" no encontrado.`);
	}
},

mostrarCodigo: function(idEtiqueta, codigo) {
	const codeFunciones = document.getElementById(idEtiqueta);
	if (codeFunciones) {
		codeFunciones.textContent = codigo;
	} else {
		console.error(`Elemento con id "${idEtiqueta}" no encontrado.`);
	}
}
};

export default Utils;</code></pre>
							<p>Nos quedaría un archivo de pruebas <code class="code-js">utils.test.js</code>:</p>
							<pre pre class="pre-largo" id="pre-ancho100"><code class="code-js">// Importa el módulo Utils
import Utils from '../../js/utils.js';

// Mock de console.error para verificar llamadas a errores
global.console = {
	error: jest.fn(),
};

describe('Pruebas para las funciones de Utils', () => {
	// Limpiar el DOM y los mocks después de cada prueba
	afterEach(() => {
	document.body.innerHTML = '';
	jest.clearAllMocks();
	});

	describe('mostrarResultado', () => {
	it('debe agregar el resultado al valor del textarea cuando el elemento existe', () => {
		// Configura el DOM con un textarea
		document.body.innerHTML = '&lt;textarea id="resultado"&gt;&lt;/textarea&gt;';
		const textarea = document.getElementById('resultado');

		// Llama a la función
		Utils.mostrarResultado('resultado', 'Prueba de resultado');

		// Verifica que el valor del textarea se haya actualizado correctamente
		expect(textarea.value).toBe('Prueba de resultado\n');
	});

	it('debe registrar un error en la consola cuando el elemento no existe', () => {
		// Llama a la función sin configurar el DOM
		Utils.mostrarResultado('resultado', 'Prueba de resultado');

		// Verifica que se haya llamado a console.error con el mensaje adecuado
		expect(console.error).toHaveBeenCalledWith('Elemento con id "resultado" no encontrado.');
	});
	});

	describe('mostrarCodigo', () => {
	it('debe establecer el contenido de texto del elemento cuando este existe', () => {
		// Configura el DOM con un elemento div
		document.body.innerHTML = '<div id="codigo"></div>';
		const div = document.getElementById('codigo');

		// Llama a la función
		Utils.mostrarCodigo('codigo', 'Código de ejemplo');

		// Verifica que el contenido de texto del div se haya establecido correctamente
		expect(div.textContent).toBe('Código de ejemplo');
	});

	it('debe registrar un error en la consola cuando el elemento no existe', () => {
		// Llama a la función sin configurar el DOM
		Utils.mostrarCodigo('codigo', 'Código de ejemplo');

		// Verifica que se haya llamado a console.error con el mensaje adecuado
		expect(console.error).toHaveBeenCalledWith('Elemento con id "codigo" no encontrado.');
	});
	});
});</code></pre>
						</section>

						<hr>
						<h3>Cobertura de código</h3>
						<p>
							Jest puede generar informes de cobertura de código para mostrar qué partes del código
							están
							cubiertas por las pruebas. Para habilitar la cobertura, ejecuta <code
								class="code-js">jest --coverage</code> o en nuestro caso: <code
								class="code-js">npm run test:jest -- --coverage</code>.
						</p>
						<p>y nos queda el <code class="code-js">jest.config.js</code> de la siguiente forma:</p>
						<pre><code class="code-js">export default {
testEnvironment: "jest-environment-jsdom", // esto habilita un DOM simulado para las pruebas en Node
setupFiles: ['<rootDir>/jest.setup.js'], // esto indica el archivo setup para el TextEncoder de JSDOM
collectCoverage: true, // Esto habilita la generación de cobertura
coverageDirectory: "coverage", // Carpeta donde se almacenará el informe de cobertura
coverageReporters: ["text", "lcov"], // Formatos de reporte (en consola y en HTML)
roots: ["<rootDir>/test/jest/"], // Solo mira este directorio correspondiente a Jest por tener jasmine en el mismo proyecto causa error spyOn
transform: {
	"^.+\\.js$": "babel-jest"
}  

};</code></pre>
						<h4>Salida al ejecutar los tests con cobertura de código:</h4>
						<div class="output">
							<pre>
<code class="code-js">> npm run test:jest -- --coverage

> fundametos-de-desarrollo-web@1.0.0 test:jest
> jest

	PASS  test/jest/EjemploPOO.test.js
	PASS  test/jest/utils.test.js     
	PASS  test/jest/Arrays.test.js    
------------------|---------|----------|---------|---------|-------------------
File              | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
------------------|---------|----------|---------|---------|-------------------
All files         |     100 |    91.66 |     100 |     100 |                   
  js              |     100 |    91.66 |     100 |     100 |                   
  Arrays.js       |     100 |     87.5 |     100 |     100 | 152               
  utils.js        |     100 |      100 |     100 |     100 |                   
  js/POO          |     100 |      100 |     100 |     100 |                   
  EjemploPOO.js   |     100 |      100 |     100 |     100 | 
------------------|---------|----------|---------|---------|-------------------

Test Suites: 3 passed, 3 total
Tests:       24 passed, 24 total
Snapshots:   0 total
Time:        6.939 s
Ran all test suites.</code>
</pre>
							<p>Se crea una página web en la carpeta recién creada coverage con el informe de Jest sobre
								la cobertura de tu código, abriendo la página index.html dentro de <code
									class="code-js">coverage/lcov-report/index.html</code>:</p>
							<img src="assets/img/jest-coverage.png" alt="jest-coverage" width="100%">
						</div>
					</section>
					<hr class="par-js">
					<section id="jasmine">
						<h2>Pruebas unitarias: Ejemplo de configuración con Jasmine</h2>
						<p>Jasmine requiere que después de intalarlo con <code
								class="code-js">npm install --save-dev jasmine</code> inicialice Jasmine para que te
							genere la ruta con el archivo<code style="color: white;">spec/support/jasmine.mjs</code></p>
						<p>Para nuestro caso al trabajar con jest y jasmine, es necesario cambiar en <code
								class="code-js">jasmine.mjs</code> la linea <code
								class="code-js">spec_dir: "test/jasmine",</code> para indicarle a Jasmine la ruta que
							revise para archivos .spec.js sin tener problemas con jest.</p>
						<p>Por otro lado es necesario indicarle a Jest que ejecute sólo las pruebas en su carpeta en el
							archivo jest.config.js con la linea <code
								class="code-js">roots: ["&lt;rootDir&gt;/test/jest/"],</code></p>
						<p>Jasmine facilita la creación de mocks utilizando <code class="code-js">spyOn</code>, que
							permite simular una función y verificar sus interacciones.</p>
						<h3>Ejemplo de configuración de Jasmine</h3>

						<p>Si vas a trabajar <strong>unicamente con jasmine</strong> y quieres ejecutar las pruebas con
							<code class="code-js">npm run test</code> en el archivo package.json coloca <code
								class="code-js">"scripts": { "test": "jasmine"}</code>.
						</p>
						<p>Para nuestro caso al tener Jest y Jasmine tenemos el package.json de la siguiente forma:</p>
						<pre><code class="code-js">{
    "name": "fundametos-de-desarrollo-web",
    "version": "1.0.0",
    "description": "Pruebas unitarias con Jest y Jasmine para ejemplos del proyecto",
    "type": "module",
    "scripts": {
        "test:jasmine": "jasmine",
        "test:jest": "jest",
        "test": "npm run test:jasmine && npm run test:jest"
    },
    "devDependencies": {
        "@babel/core": "^7.21.0",
        "@babel/preset-env": "^7.21.0",
        "babel-jest": "^29.7.0",
        "jasmine": "^5.6.0",
        "jest": "^29.7.0",
        "jest-environment-jsdom": "^29.7.0"
    }
}</code></pre>

						<h3>Ejecutar las pruebas</h3>
						<p>
							Ejecuta <code class="code-js">npm run test</code> o <code
								class="code-js">npm run test:jasmine</code> en la terminal para ejecutar las pruebas.
							Jasmine
							buscará archivos con el sufijo <code class="code-js">.spec.js</code> y ejecutará las
							pruebas
							definidas en ellos.
						</p>


						<h3>Conceptos clave de Jasmine</h3>
						<ul>
							<li><strong>describe:</strong> Agrupa pruebas relacionadas.</li>
							<li><strong>it:</strong> Define una prueba individual.</li>
							<li><strong>expect:</strong> Crea afirmaciones para validar el comportamiento.</li>
							<li><strong>toBe:</strong> Comprueba igualdad estricta.</li>
							<li><strong>toEqual:</strong> Comprueba igualdad profunda para objetos o arrays.</li>
							<li><strong>beforeEach y afterEach:</strong> Ejecutan código antes y después de cada prueba
								individual.</li>
							<li><strong>spyOn:</strong> Crea un espía para simular y rastrear funciones.</li>
						</ul>
						<p>Veamos un ejemplo sencillo antes de hacer un ejemplo real</p>
						<h3>Ejemplo con <code class="code-js">describe</code> y <code class="code-js">spyOn</code></h3>
						<p>Código a evaluar:</p>
						<pre><code class="code-js">// notificaciones.js
function enviarNotificacion(mensaje) {
  console.log("Notificación enviada:", mensaje);
  return true;
}</code></pre>
						<p>Prueba en <code style="color: white;">test/jasmine/notificaciones.spec.js</code></p>
						<pre><code class="code-js">// notifiaciones.spec.js
	describe("Pruebas de notificaciones", function() {
  it("debe llamar a enviarNotificacion con el mensaje correcto", function() {
    spyOn(window, "enviarNotificacion").and.returnValue(true);
    const resultado = enviarNotificacion("Hola, Jasmine");
    expect(enviarNotificacion).toHaveBeenCalled();
    expect(enviarNotificacion).toHaveBeenCalledWith("Hola, Jasmine");
    expect(resultado).toBe(true);
  });
});</code></pre>
						<p>Ejecuta <code class="code-js">npm run test</code> o <code
								class="code-js">npm run test:jasmine</code>
							en
							la terminal para ejecutar las pruebas.</p>
						<p>
							<strong>¿Qué hace la función?</strong>
						</p>
						<ol>
							<li>
								<strong>La función <code class="code-js">enviarNotificacion</code>simula el envío de una
									notificación.
								</strong>
							</li>
							<li>prueba con describe y spyOn:</li>
							<ul>
								<li><code class="code-js">aspyOn</code> crea un "espía" que permite simular el
									comportamiento de una función.</li>
								<li>La prueba verifica que la función enviarNotificacion se haya llamado con el mensaje
									correcto y que devuelva el valor esperado.</li>
							</ul>
						</ol>
						<hr>
						<h3>Ejemplo pruebas unitarias con jasmine: Métodos de Orden superior de Arrays</h3>
						<p>Para el primer ejemplo con Jasmine podemos hacer las pruebas para <code
								class="code-js">funcionesOdenSuperiorArrays.js</code></p>
						<p>Código a evaluar de métodos de orden superior de arrays:</p>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">import Utils from './utils.js';
const idResultado = 'resultado-metodos-arrays-orden-superior';
const idCode = 'code-metodos-arrays-orden-superior-mostrar';

	
//   Funciones Impuras de Orden Superior de Arrays


/* forEach()
	- Ejemplo impuro: recorre cada elemento y concatena un string (efecto secundario).
	- No devuelve un nuevo array.
*/
function ejecutarForEach() {
	const array = [1, 2, 3, 4];
	let resultado = "";
	array.forEach((element, index) => {
		resultado += `Elemento ${index}: ${element}\n`;
	});
	const codigo = `const array = [1, 2, 3, 4];
let resultado = "";
array.forEach((element, index) => {
	resultado += \`Elemento \${index}: \${element}\\n\`;
});
console.log(resultado);`;
	Utils.mostrarResultado(idResultado, resultado);
	Utils.mostrarCodigo(idCode, codigo);
}

/* sort()
	- Ejemplo impuro: ordena el array original según una función de comparación.
	- Modifica el array original, por lo que no es pura.
*/
function ejecutarArraySort() {
	const array = [3, 1, 4, 2];
	array.sort((a, b) => a - b);
	const codigo = `const array = [3, 1, 4, 2];
array.sort((a, b) => a - b); // Ahora array es [1, 2, 3, 4]`;
	Utils.mostrarResultado(idResultado, `Array ordenado: ${array}`);
	Utils.mostrarCodigo(idCode, codigo);
}

	
//   Funciones Puros de Orden Superior de Arrays


/* map()
	- Aplica una función a cada elemento del array y devuelve un nuevo array.
	- No modifica el array original.
*/
function ejecutarArrayMap() {
	const array = [1, 2, 3, 4];
	const mapped = array.map(x => x * 2);
	const codigo = `const array = [1, 2, 3, 4];
const mapped = array.map(x => x * 2); // mapped es [2, 4, 6, 8]`;
	Utils.mostrarResultado(idResultado, `Array mapeado (cada elemento * 2): ${mapped}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* filter()
	- Devuelve un nuevo array con los elementos que cumplen la condición.
	- No altera el array original.
*/
function ejecutarArrayFilter() {
	const array = [1, 2, 3, 4, 5, 6];
	const filtered = array.filter(x => x % 2 === 0);
	const codigo = `const array = [1, 2, 3, 4, 5, 6];
const filtered = array.filter(x => x % 2 === 0); // filtered es [2, 4, 6]`;
	Utils.mostrarResultado(idResultado, `Array filtrado (solo pares): ${filtered}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* reduce()
	- Recorre el array y acumula sus elementos en un único valor mediante una función acumuladora.
	- Devuelve el resultado sin modificar el array original.
*/
function ejecutarArrayReduce() {
	const array = [1, 2, 3, 4];
	const sum = array.reduce((acc, curr) => acc + curr, 0);
	const codigo = `const array = [1, 2, 3, 4];
const sum = array.reduce((acc, curr) => acc + curr, 0); // sum es 10`;
	Utils.mostrarResultado(idResultado, `Suma de elementos con reduce: ${sum}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* some()
	- Comprueba si al menos un elemento cumple con la condición del callback.
	- Devuelve un booleano sin modificar el array.
*/
function ejecutarArraySome() {
	const array = [1, 3, 5, 7];
	const hasEven = array.some(x => x % 2 === 0);
	const codigo = `const array = [1, 3, 5, 7];
const hasEven = array.some(x => x % 2 === 0); // hasEven es false`;
	Utils.mostrarResultado(idResultado, `¿Algún elemento es par? ${hasEven}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* every()
	- Verifica si todos los elementos cumplen la condición.
	- Devuelve un booleano sin alterar el array.
*/
function ejecutarArrayEvery() {
	const array = [2, 4, 6, 8];
	const allEven = array.every(x => x % 2 === 0);
	const codigo = `const array = [2, 4, 6, 8];
const allEven = array.every(x => x % 2 === 0); // allEven es true`;
	Utils.mostrarResultado(idResultado, `¿Todos los elementos son pares? ${allEven}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* find()
	- Devuelve el primer elemento que cumple la condición.
	- No modifica el array original.
*/
function ejecutarArrayFind() {
	const array = [5, 12, 8, 130, 44];
	const found = array.find(x => x > 10);
	const codigo = `const array = [5, 12, 8, 130, 44];
const found = array.find(x => x > 10); // found es 12, el primer elemento mayor que 10`;
	Utils.mostrarResultado(idResultado, `Primer elemento mayor a 10: ${found}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* findIndex()
	- Devuelve el índice del primer elemento que cumple la condición o -1 si ninguno la cumple.
	- Es una función pura.
*/
function ejecutarArrayFindIndex() {
	const array = [5, 12, 8, 130, 44];
	const index = array.findIndex(x => x > 10);
	const codigo = `const array = [5, 12, 8, 130, 44];
const index = array.findIndex(x => x > 10); // index es 1`;
	Utils.mostrarResultado(idResultado, `Índice del primer elemento mayor a 10: ${index}`);
	Utils.mostrarCodigo(idCode, codigo);
}

/* flatMap()
	- Aplica una función a cada elemento y luego aplana el resultado en un nuevo array.
	- No modifica el array original.
*/
function ejecutarArrayFlatMap() {
	const array = [1, 2, 3];
	const flatMapped = array.flatMap(x => [x, x * 2]);
	const codigo = `const array = [1, 2, 3];
const flatMapped = array.flatMap(x => [x, x * 2]);
// flatMapped es [1, 2, 2, 4, 3, 6]`;
	Utils.mostrarResultado(idResultado, `Array flatMap (cada elemento y su doble): ${flatMapped}`);
	Utils.mostrarCodigo(idCode, codigo);
}

export {
	ejecutarForEach,
	ejecutarArraySort,
	ejecutarArrayMap,
	ejecutarArrayFilter,
	ejecutarArrayReduce,
	ejecutarArraySome,
	ejecutarArrayEvery,
	ejecutarArrayFind,
	ejecutarArrayFindIndex,
	ejecutarArrayFlatMap
};
</code></pre>
						<p>Pruebas unitarias con <code class="code-js">funcionesOrdenSuperiorArrays.spec.js</code>:</p>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">import * as Funciones from '../../js/funcionesOrdenSuperiorArrays.js';
	import Utils from '../../js/utils.js';
	
	// Simula las funciones de Utils con Jasmine (similar a Jest pero con spies)
	beforeEach(() => {
	  spyOn(Utils, 'mostrarResultado'); // Crea un espía para `mostrarResultado`
	  spyOn(Utils, 'mostrarCodigo');    // Crea un espía para `mostrarCodigo`
	});
	
	describe('Funciones de Orden Superior para Arrays', () => {
	  describe('ejecutarForEach', () => {
		it('debería recorrer el array y mostrar los elementos con índices', () => {
		  Funciones.ejecutarForEach();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Elemento 0: 1\nElemento 1: 2\nElemento 2: 3\nElemento 3: 4\n'
		  );
		});
	  });
	
	  describe('ejecutarArraySort', () => {
		it('debería ordenar el array de forma ascendente', () => {
		  Funciones.ejecutarArraySort();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Array ordenado: 1,2,3,4'
		  );
		});
	  });
	
	  describe('ejecutarArrayMap', () => {
		it('debería mapear el array y multiplicar cada elemento por 2', () => {
		  Funciones.ejecutarArrayMap();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Array mapeado (cada elemento * 2): 2,4,6,8'
		  );
		});
	  });
	
	  describe('ejecutarArrayFilter', () => {
		it('debería filtrar los elementos pares del array', () => {
		  Funciones.ejecutarArrayFilter();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Array filtrado (solo pares): 2,4,6'
		  );
		});
	  });
	
	  describe('ejecutarArrayReduce', () => {
		it('debería reducir el array sumando sus elementos', () => {
		  Funciones.ejecutarArrayReduce();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Suma de elementos con reduce: 10'
		  );
		});
	  });
	
	  describe('ejecutarArraySome', () => {
		it('debería verificar si al menos un elemento es par', () => {
		  Funciones.ejecutarArraySome();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'¿Algún elemento es par? false'
		  );
		});
	  });
	
	  describe('ejecutarArrayEvery', () => {
		it('debería verificar si todos los elementos son pares', () => {
		  Funciones.ejecutarArrayEvery();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'¿Todos los elementos son pares? true'
		  );
		});
	  });
	
	  describe('ejecutarArrayFind', () => {
		it('debería encontrar el primer elemento mayor a 10', () => {
		  Funciones.ejecutarArrayFind();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Primer elemento mayor a 10: 12'
		  );
		});
	  });
	
	  describe('ejecutarArrayFindIndex', () => {
		it('debería devolver el índice del primer elemento mayor a 10', () => {
		  Funciones.ejecutarArrayFindIndex();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Índice del primer elemento mayor a 10: 1'
		  );
		});
	  });
	
	  describe('ejecutarArrayFlatMap', () => {
		it('debería aplanar el array después de duplicar cada elemento', () => {
		  Funciones.ejecutarArrayFlatMap();
	
		  expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-metodos-arrays-orden-superior',
			'Array flatMap (cada elemento y su doble): 1,2,2,4,3,6'
		  );
		});
	  });
	});
	</code></pre>
						<p>Ejecuta <code class="code-js">npm run test</code> o <code
								class="code-js">npm run test:jasmine</code>
							en la terminal para ejecutar las pruebas.</p>
						<p><strong>¿Qué hace la función?</strong></p>
						<ol>
							<li>
								<strong>La función <code class="code-js">ejecutarForEach</code> recorre un array y
									realiza una acción sobre cada elemento.</strong>
							</li>
							<li>Pruebas clave utilizando Jasmine:</li>
							<ul>
								<li><code class="code-js">describe</code> agrupa las pruebas relacionadas, como todas
									las pruebas de métodos de orden superior.</li>
								<li><code class="code-js">spyOn</code> crea un "espía" para simular y rastrear el
									comportamiento de funciones como <code class="code-js">mostrarResultado</code>.</li>
								<li>Las pruebas validan que las funciones como <code
										class="code-js">ejecutarForEach</code> y otras sean llamadas correctamente y
									generen los resultados esperados.</li>
							</ul>
						</ol>
						<p>Resultado de la prueba con Jasmine de métodos de orden superior de arrays:</p>
						<pre><code class="code-js">
	> fundametos-de-desarrollo-web@1.0.0 test:jasmine
	> jasmine
	
	Randomized with seed 04805
	Started
	..........
	
	
	10 specs, 0 failures
	Finished in 0.024 seconds
	Randomized with seed 04805 (jasmine --random=true --seed=04805)</code></pre>
						<hr>


						<h3>Pruebas asíncronas</h3>
						<p>
							Jasmine también permite probar código asíncrono utilizando <code class="code-js">done</code>
							o promesas:
						</p>
						<p>Código a evaluar de función que solicita los datos de la localidad 3: "Citadel of Ricks" en
							la API de Rick y Morty.</p>
						<pre><code class="code-js">// asyncAwaitFetch-RickMorty.js
// Función para obtener la ubicación (Citadel of Ricks)
export async function obtenerUbicacion() {
	try {
		Utils.mostrarResultado(idResultado, 'Solicitando ubicación a la API de Rick y Morty...'); // debería ser console.log
		const respuesta = await fetch('https://rickandmortyapi.com/api/location/3');
		if (!respuesta.ok) {
			throw new Error(`Error HTTP: ${respuesta.status}`);
		}
		const ubicacion = await respuesta.json();

		Utils.mostrarResultado(idResultado,'Ubicación obtenida: ' + ubicacion); // ${JSON.stringify(ubicacion)} mostrar respuesta completa
		return ubicacion;
	} catch (error) {
		Utils.mostrarResultado(idResultado,'Error al obtener la ubicación: ' + error); // debería ser console.error
		throw error;
	}
}</code></pre>
						<p>Prueba en <code style="color: white;">test/jasmine/asyncAwaitFetch-RickMorty.spec.js</code>
						</p>
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">import { obtenerUbicacion } from '../../js/asyncAwaitFetch-RickyMorty.js';
import Utils from '../../js/utils.js';


// asyncAwaitFetch-RickMorty.spec.js
//prueba sólo a la primera solicitud obtenerUbicación
describe("Pruebas para la función obtenerUbicacion", () => {
	let originalFetch;
	let originalMostrarResultado;
	const idResultado = 'resultado-Rick-y-Morty';

	beforeEach(() => {
		// Guardamos los métodos originales para restaurarlos luego
		originalFetch = global.fetch;
		originalMostrarResultado = Utils.mostrarResultado;

		// Mock de la función fetch
		global.fetch = jasmine.createSpy("fetch");

		// Mock de Utils.mostrarResultado
		Utils.mostrarResultado = jasmine.createSpy("mostrarResultado");
	});

	afterEach(() => {
		// Restauramos los métodos originales después de cada prueba
		global.fetch = originalFetch;
		Utils.mostrarResultado = originalMostrarResultado;
	});

	it("debería obtener la ubicación correctamente y llamar a mostrarResultado con la ubicación", async () => {
		const mockResponse = {
			ok: true,
			json: async () => ({
				id: 3,
				name: "Citadel of Ricks",
				type: "Space station",
				dimension: "Unknown dimension"
			})
		};

		global.fetch.and.returnValue(Promise.resolve(mockResponse));

		const ubicacion = await obtenerUbicacion();

		// Verifica que fetch fue llamado con la URL correcta
		expect(global.fetch).toHaveBeenCalledWith("https://rickandmortyapi.com/api/location/3");

			// Verifica que mostrarResultado se llamó con el mensaje correcto para la ubicación obtenida
			expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-Rick-y-Morty',
			"Ubicación obtenida: [object Object]"
		);

		// Verifica que la función devolvió la ubicación correcta
		expect(ubicacion).toEqual(await mockResponse.json());
	});

	it("debería manejar un error HTTP y llamar a mostrarResultado con el mensaje de error", async () => {
		const mockErrorResponse = {
			ok: false,
			status: 404
		};

		global.fetch.and.returnValue(Promise.resolve(mockErrorResponse));

		try {
			await obtenerUbicacion();
			fail("Se esperaba que lanzara un error HTTP");
		} catch (error) {
			// Verifica que se lanzó el error esperado
			expect(error.message).toBe("Error HTTP: 404");

			// Verifica que fetch fue llamado con la URL correcta
			expect(global.fetch).toHaveBeenCalledWith("https://rickandmortyapi.com/api/location/3");

			// Verifica que mostrarResultado se llamó con el mensaje de error
			expect(Utils.mostrarResultado).toHaveBeenCalledWith(
				idResultado,
				"Error al obtener la ubicación: " + error
			);
		}
	});

	it("debería manejar un error de red y llamar a mostrarResultado con el mensaje de error", async () => {
		const networkError = new Error("Fallo en la red");
		global.fetch.and.returnValue(Promise.reject(networkError));

		try {
			await obtenerUbicacion();
			fail("Se esperaba que lanzara un error de red");
		} catch (error) {
			// Verifica que se lanzó el error esperado
			expect(error.message).toBe("Fallo en la red");

			// Verifica que fetch fue llamado con la URL correcta
			expect(global.fetch).toHaveBeenCalledWith("https://rickandmortyapi.com/api/location/3");

			// Verifica que mostrarResultado se llamó con el mensaje de error
			expect(Utils.mostrarResultado).toHaveBeenCalledWith(
				idResultado,
				"Error al obtener la ubicación: " + error
			);
		}
	});
});</code></pre>
						<p>Ejecuta <code class="code-js">npm run test</code> o <code
								class="code-js">npm run test:jasmine</code>
							en
							la terminal para ejecutar las pruebas.</p>
						<p>
							<strong>¿Qué hace la función?</strong>
						</p>
						<ol>
							<li>
								La función <code class="code-js">obtenerUbicacion</code> realiza una solicitud HTTP GET
								a la API de Rick y Morty para obtener información sobre la ubicación con ID 3 (Citadel
								of Ricks).
							</li>
							<li>
								Maneja tres escenarios principales:
								<ul>
									<li>Respuesta exitosa de la API: Muestra el mensaje <code
											class="code-js">"Ubicación obtenida: [object Object]"</code> con el
										resultado de la solicitud.</li>
									<li>Error HTTP (por ejemplo, código de estado 404): Lanza un mensaje de error como
										<code style="color: red;">"Error HTTP: 404"</code>.
									</li>
									<li>Error de red (por ejemplo, fallo de conexión): Lanza un mensaje como <code
											style="color: red;">"Error al obtener la ubicación: Fallo en la red"</code>.
									</li>
								</ul>
							</li>
							<li>
								Usa <code class="code-js">Utils.mostrarResultado</code> para mostrar resultados o
								errores en la interfaz de usuario.
							</li>
						</ol>
						<p>Resultado de la ejecución de las pruebas:</p>
						<div class="output">
							<pre><code class="code-js">npm run test:jasmine   

	> fundametos-de-desarrollo-web@1.0.0 test:jasmine
	> jasmine
	
	Randomized with seed 37758
	Started
	.............
	
	
	13 specs, 0 failures
	Finished in 0.023 seconds
	Randomized with seed 37758 (jasmine --random=true --seed=37758)</code></pre>
						</div>
					</section>
				</article>
				<hr>
				<article id="ejemplo-prueba-unitaria">
					<h3>Ejemplo completo de prueba unitaria con Jasmine</h3>
					<p>En el siguiente ejemplo vamos a hacer un Mock con Jasmine para hacer una prueba unitaria que
						verifique el correcto funcionamiento del ejemplo de async await con fetch para hacer una
						solicitud a la API de Rick y Morty.</p>
					<p>Para poder simular el DOM recuerda que podemos utilizar JSDOM ejecutando en la terminal: <code
							class="code-js">npm install --save-dev jsdom</code></p>

					<p>En archivo: <code class="code-js">asyncAwait-RickMorty.js</code></p>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js">
// En archivo: asyncAwait-RickMorty.js
// --- Código a probar (simulación del módulo) ---
import Utils from './utils.js';
const idResultado = 'resultado-Rick-y-Morty';
const idCode = 'code-Rick-y-Morty-mostrar';

// Función para generar un color aleatorio para cada card
function generarColorAleatorio() {
	const letras = '0123456789ABCDEF';
	let color = '#';
	for (let i = 0; i &lt; 6; i++) {
		color += letras[Math.floor(Math.random() * 16)];
	}
	return color;
}

// Función para obtener la ubicación (Citadel of Ricks)
async function obtenerUbicacion() {
	try {
		Utils.mostrarResultado(idResultado, 'Solicitando ubicación a la API de Rick and Morty...');
		const respuesta = await fetch('https://rickandmortyapi.com/api/location/3');
		if (!respuesta.ok) {
			throw new Error(`Error HTTP: ${respuesta.status}`);
		}
		const ubicacion = await respuesta.json();
		Utils.mostrarResultado(idResultado, 'Ubicación obtenida: ' + JSON.stringify(ubicacion));
		return ubicacion;
	} catch (error) {
		Utils.mostrarResultado(idResultado, 'Error al obtener la ubicación: ' + error);
		throw error;
	}
}

// Función para obtener la información de cada residente usando Promise.all
async function obtenerResidentes(urls) {
	try {
		const fetchPromises = urls.map(url => fetch(url).then(res => {
			if (!res.ok) {
				throw new Error(`Error HTTP en ${url}: ${res.status}`);
			}
			return res.json();
		}));
		const residentes = await Promise.all(fetchPromises);
		Utils.mostrarResultado(idResultado, 'Residentes obtenidos: ' + residentes.map(residente => `${residente.id} ${residente.name}`).join(', '));
		return residentes;
	} catch (error) {
		Utils.mostrarResultado(idResultado, 'Error al obtener los residentes: ' + error);
		throw error;
	}
}

// Función para crear y mostrar las cards de cada residente
function mostrarCards(residentes) {
	const container = document.getElementById('container-Rick-y-Morty');
	residentes.forEach(residente => {
		const card = document.createElement('div');
		card.classList.add('card');
		card.style.backgroundColor = generarColorAleatorio();
		card.innerHTML = `
			&lt;img src="${residente.image}" alt="${residente.name}"&gt;
			&lt;h5&gt;ID: ${residente.id}&lt;/h5&gt;
			&lt;h4&gt;${residente.name}&lt;/h4&gt;
			&lt;p&gt;&lt;strong&gt;Location:&lt;/strong&gt; ${residente.location.name}&lt;/p&gt;
			&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; ${residente.status}&lt;/p&gt;
		`;
		container.appendChild(card);
	});
}

// Función principal que orquesta la solicitud y muestra los resultados
async function ejecutarEjemploRickYMorty() {
	try {
		const container = document.getElementById('container-Rick-y-Morty');
		container.innerHTML = ''; // Limpiar contenedor
		const ubicacion = await obtenerUbicacion();
		const residentes = await obtenerResidentes(ubicacion.residents);
		mostrarCards(residentes);
		Utils.mostrarResultado(idResultado, 'Ejemplo ejecutado correctamente.');
	} catch (error) {
		Utils.mostrarResultado(idResultado, 'Error: ' + error);
	} finally {
		const codigo = ''; // Código para mostrar en el editor (si se desea)
		Utils.mostrarCodigo(idCode, codigo);
	}
}

// --- Fin del código a probar ---
</code></pre>
					<p>En Archivo: <code class="code-js">asyncAwaitFetch-completoRickyMorty.spec</code></p>
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js">import { JSDOM } from 'jsdom';
import { ejecutarEjemploRickYMorty } from '../../js/asyncAwaitFetch-RickyMorty.js';
import Utils from '../../js/utils.js';

describe("Pruebas para la función ejecutarEjemploRickYMorty", () => {
	let originalFetch;
	let originalMostrarResultado;
	let originalMostrarCodigo;
	let dom;

	beforeEach(() => {
		// Simula un DOM con jsdom
		dom = new JSDOM(`<!DOCTYPE html><div id="container-Rick-y-Morty"></div>`);
		global.document = dom.window.document;
		global.window = dom.window;

		// Mock de métodos originales
		originalFetch = global.fetch;
		originalMostrarResultado = Utils.mostrarResultado;
		originalMostrarCodigo = Utils.mostrarCodigo;

		// Mock de Utils
		Utils.mostrarResultado = jasmine.createSpy("mostrarResultado");
		Utils.mostrarCodigo = jasmine.createSpy("mostrarCodigo");
	});

	afterEach(() => {
		// Restauramos métodos originales
		global.fetch = originalFetch;
		Utils.mostrarResultado = originalMostrarResultado;
		Utils.mostrarCodigo = originalMostrarCodigo;
		delete global.document;
		delete global.window;
	});

	it("debería ejecutar correctamente la función y mostrar los resultados", async () => {
		// Mock de fetch para obtener ubicación y residentes
		global.fetch = jasmine.createSpy("fetch").and.callFake((url) => {
			if (url === "https://rickandmortyapi.com/api/location/3") {
				return Promise.resolve({
					ok: true,
					json: async () => ({
						residents: ["https://rickandmortyapi.com/api/character/1"]
					})
				});
			} else if (url === "https://rickandmortyapi.com/api/character/1") {
				return Promise.resolve({
					ok: true,
					json: async () => ({
						id: 1,
						name: "Rick Sanchez",
						status: "Alive",
						location: { name: "Earth" },
						image: "https://rickandmortyapi.com/api/character/avatar/1.jpeg"
					})
				});
			}
		});

		// Ejecuta la función principal
		await ejecutarEjemploRickYMorty();

		// Verifica que se generó correctamente una card
		const cards = document.getElementsByClassName('card');
		expect(cards.length).toBe(1);
		expect(cards[0].querySelector('h4').textContent).toBe("Rick Sanchez");

		// Verifica que Utils.mostrarResultado se llamó con éxito
		expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-Rick-y-Morty',
			'Ejemplo ejecutado correctamente.'
		);
	});

	it("debería manejar errores al obtener la ubicación", async () => {
		// Mock de fetch para fallar al obtener la ubicación
		global.fetch = jasmine.createSpy("fetch").and.returnValue(
			Promise.reject(new Error("Fallo en obtener la ubicación"))
		);

		// Ejecuta la función principal
		await ejecutarEjemploRickYMorty();

		// Verifica que Utils.mostrarResultado se llamó con el error
		expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-Rick-y-Morty',
			'Error: Error: Fallo en obtener la ubicación'
		);
	});

	it("debería manejar errores al obtener residentes", async () => {
		// Mock de fetch para obtener ubicación, pero fallar al obtener residentes
		global.fetch = jasmine.createSpy("fetch").and.callFake((url) => {
			if (url === "https://rickandmortyapi.com/api/location/3") {
				return Promise.resolve({
					ok: true,
					json: async () => ({
						residents: ["https://rickandmortyapi.com/api/character/1"]
					})
				});
			} else if (url === "https://rickandmortyapi.com/api/character/1") {
				return Promise.reject(new Error("Fallo en obtener residentes"));
			}
		});

		// Ejecuta la función principal
		await ejecutarEjemploRickYMorty();

		// Verifica que Utils.mostrarResultado se llamó con el error
		expect(Utils.mostrarResultado).toHaveBeenCalledWith(
			'resultado-Rick-y-Morty',
			'Error: Error: Fallo en obtener residentes'
		);
	});
});</code></pre>

					<p>Ejecuta <code class="code-js">npm run test</code> o <code
							class="code-js">npm run test:jasmine</code> en
						la terminal para ejecutar las pruebas.</p>
					<p>
					<div id="container-prueba-unitaria">
						<p>
							<strong>¿Qué hace la función?</strong>
						</p>
						<ol>
							<li>
								<strong>Simula un DOM para las pruebas:</strong> La función utiliza <code
									class="code-js">jsdom</code> para crear un entorno DOM virtual, generando un
								contenedor llamado <code class="code-js">container-Rick-y-Morty</code>. Esto permite
								probar interacciones con el DOM, como la creación de cards.
							</li>
							<li>
								<strong>Obtiene datos de la API de Rick and Morty:</strong> La función realiza
								solicitudes a dos endpoints principales:
								<ul>
									<li><code class="code-js">/api/location/3</code>: Para obtener los detalles de la
										ubicación llamada "Citadel of Ricks" y sus residentes.</li>
									<li><code class="code-js">/api/character/1</code>: Para obtener información
										detallada sobre el residente "Rick Sanchez".</li>
								</ul>
							</li>
							<li>
								<strong>Genera elementos visuales:</strong> Con la información obtenida de la API, crea
								y agrega cards en el contenedor del DOM. Cada card incluye datos como imagen, nombre,
								ID, ubicación y estado.
							</li>
							<li>
								<strong>Maneja errores:</strong> En caso de errores, ya sea al obtener la ubicación o
								los residentes, muestra mensajes de error usando <code
									class="code-js">Utils.mostrarResultado</code>.
							</li>
							<li>
								<strong>Registra el progreso:</strong> Muestra mensajes como <code
									class="code-js">"Ejemplo ejecutado correctamente"</code> cuando todo se ejecuta sin
								problemas, o mensajes detallados de error en caso contrario.
							</li>
						</ol>
						<p>
							Las pruebas verifican la correcta ejecución de la función <code
								class="code-js">ejecutarEjemploRickYMorty</code> en tres escenarios principales:
						</p>
						<ul>
							<li><strong>Ejecución exitosa</strong>: Comprueba que la función obtenga datos de la API y
								genere
								correctamente cards en el DOM.</li>
							<li><strong>Error al obtener la ubicación</strong>: Verifica cómo la función maneja fallos
								al realizar la
								solicitud a <code class="code-js">/api/location/3</code>.</li>
							<li><strong>Error al obtener residentes</strong>: Valida que la función maneje adecuadamente
								errores
								durante la solicitud a <code class="code-js">/api/character/1</code>.</li>
						</ul>
						<h5>Detalles clave del código</h5>
						<ol>
							<li>
								<strong>Simulación de la API:</strong>
								<ul>
									<li>Se utiliza <code class="code-js">spyOn(window, 'fetch').and.callFake(...)</code>
										para interceptar las llamadas a <code class="code-js">fetch</code> y simular la
										respuesta de la API.</li>
									<li>Se utiliza <code class="code-js">Promise.resolve</code> para simular una
										respuesta exitosa de la API.</li>
								</ul>
							</li>
							<li>
								<strong>Verificación de mensajes:</strong> Se utiliza <code
									class="code-js">expect(Utils.mostrarResultado).toHaveBeenCalledWith(...)</code>
								para verificar que se hayan llamado a <code
									class="code-js">Utils.mostrarResultado</code> con los mensajes esperados.
							</li>
							<li>
								Se utiliza JSDOM para simular el DOM para <code class="code-js">mostrarCards</code>.
							</li>
						</ol>
						<h5>Comportamiento del test</h5>
						<ol>
							<li>Se simula la respuesta de la API para la URL de la ubicación.</li>
							<li>Se ejecuta la función <code class="code-js">ejecutarEjemploRickYMorty</code>.</li>
							<li>Se verifica que se hayan llamado a <code class="code-js">Utils.mostrarResultado</code>
								con
								los mensajes esperados.</li>
							<li>La prueba pasa si todas las verificaciones son exitosas.</li>
						</ol>
						<h5>Explicación del Test con jasmine</h5>
						<ol>
							<li><strong>Configuración del Spy:</strong> Se utiliza <code
									class="code-js">spyOn(Utils, 'mostrarResultado').and.callThrough()</code> para
								interceptar todas las llamadas a la función <code
									class="code-js">Utils.mostrarResultado</code> y permitir su ejecución normal. De
								esta manera, podemos verificar que se hayan emitido los mensajes esperados durante
								la ejecución.</li>
							<li><strong>Simulación de la API (Mocking de <code class="code-js">fetch</code>):</strong>
								Con <code class="code-js">spyOn(window, 'fetch').and.callFake(...)</code> se intercepta
								la
								llamada a <code class="code-js">fetch</code> para la URL de la ubicación,
								devolviendo una respuesta
								simulada Promise.resolve(). Esto permite controlar el flujo sin realizar llamadas
								reales a la API.</li>
							<li><strong>Ejecución y Verificación:</strong> Se ejecuta
								<code class="code-js">ejecutarEjemploRickYMorty()</code> y se verifica mediante
								expectativas
								(<code class="code-js">expect</code>) que se hayan llamado a <code
									class="code-js">Utils.mostrarResultado</code> con
								mensajes que incluyan "Solicitando ubicación", "Ubicación obtenida" y "Ejemplo
								ejecutado correctamente". Esto confirma que la función se comporta como se espera.
							</li>
						</ol>
						<div class="output">
							<pre><code class="code-js">> fundametos-de-desarrollo-web@1.0.0 test:jasmine
> jasmine

Randomized with seed 30286
Started
................


16 specs, 0 failures
Finished in 0.172 seconds
Randomized with seed 30286 (jasmine --random=true --seed=30286)</code></pre>
						</div>
						<p>Considera que se muestran el archivo <code
								class="code-js">asyncAwaitFetch-RickyMorty.js</code> y
							<code class="code-js">asyncAwaitFetch-completoRickyMorty.spec.js</code> para hacer el
							ejemplo de
							Jasmine que requiere el <code class="code-js">package.json</code> configurado correctamente.
						</p>
					</div>
					<h3>Generar reporte de pruebas</h3>
					<p>
						Jasmine también se integra con herramientas para generar reportes de pruebas. Configura tu
						reporter favorito en <code class="code-js">jasmine.mjs</code>.
					</p>
					<ol>
						<li>
							Instalar un paquete de reporte (opcional pero recomendado):
							<pre><code class="code-js">npm install jasmine-spec-reporter --save-dev</code></pre>
						</li>
						<li>
							Configurar <code class="code-js">jasmine.mjs</code>
							<pre><code style="color: white;">export default {
	spec_dir: "test/jasmine",
	spec_files: [
		"**/*[sS]pec.?(m)js"
	],
	<mark>helpers: [
		"helpers/**/*.?(m)js"</mark> // Debemos crear el archivo de configuraciónes adicionales
	],
	env: {
		stopSpecOnExpectationFailure: false,
		random: true,
		forbidDuplicateNames: true
	}
}
	</code></pre>
						</li>
						<li>
							Configura el archivo <code class="code-js">reporter.mjs</code><br>
							Crea el archivo <code class="code-js">helpers/reporter.mjs</code> con el siguiente contenido
							para integrar <code class="code-js">jasmine-spec-reporter</code>:
							<pre><code style="color: white;">import { SpecReporter } from 'jasmine-spec-reporter';

// Configuración de SpecReporter para resultados en consola
jasmine.getEnv().clearReporters(); // Limpia los reportes predeterminados
jasmine.getEnv().addReporter(new SpecReporter({
	spec: {
	displayStacktrace: "pretty"
	}
}));</code></pre>
						</li>
						<li>
							Ejecuta los test con <code class="code-js">npm run test</code> o <code
								class="code-js">npm run test:jasmine</code>
						</li>
					</ol>
					<div class="output">
						<pre class="pre-largo" id="pre-ancho100"><code class="code-js">npm run test:jasmine   

> fundametos-de-desarrollo-web@1.0.0 test:jasmine
> jasmine

Jasmine started

	Pruebas para la función ejecutarEjemploRickYMorty
	√ debería ejecutar correctamente la función y mostrar los resultados
	√ debería manejar errores al obtener la ubicación
	√ debería manejar errores al obtener residentes

	Funciones de Orden Superior para Arrays

	ejecutarArrayReduce
		√ debería reducir el array sumando sus elementos

	ejecutarArraySome
		√ debería verificar si al menos un elemento es par

	ejecutarArrayMap
		√ debería mapear el array y multiplicar cada elemento por 2

	ejecutarArrayFilter
		√ debería filtrar los elementos pares del array

	ejecutarForEach
		√ debería recorrer el array y mostrar los elementos con índices

	ejecutarArraySort
		√ debería ordenar el array de forma ascendente

	ejecutarArrayFindIndex
		√ debería devolver el índice del primer elemento mayor a 10

	ejecutarArrayFind
		√ debería encontrar el primer elemento mayor a 10

	ejecutarArrayEvery
		√ debería verificar si todos los elementos son pares

	ejecutarArrayFlatMap
		√ debería aplanar el array después de duplicar cada elemento

	Pruebas para la función obtenerUbicacion
	√ debería manejar un error de red y llamar a mostrarResultado con el mensaje de error
	√ debería obtener la ubicación correctamente y llamar a mostrarResultado con la ubicación
	√ debería manejar un error HTTP y llamar a mostrarResultado con el mensaje de error

Executed 16 of 16 specs SUCCESS in 0.184 sec.
Randomized with seed 30399.</code></pre>
					</div>
				</article>
			</section>
			<hr>
			<section id="pruebas-unitarias-resultados">
				<h3>El resultado de todas las pruebas unitarias ejecutando <code class="code-js">npm run test</code> es
					el siguiente:</h3>
				<div class="output">
					<pre class="pre-largo" id="pre-ancho100"><code class="code-js">npm run test

> fundametos-de-desarrollo-web@1.0.0 test
> npm run test:jasmine && npm run test:jest


> fundametos-de-desarrollo-web@1.0.0 test:jasmine
> jasmine

Jasmine started

	Pruebas para la función obtenerUbicacion
	√ debería manejar un error de red y llamar a mostrarResultado con el mensaje de error
	√ debería obtener la ubicación correctamente y llamar a mostrarResultado con la ubicación
	√ debería manejar un error HTTP y llamar a mostrarResultado con el mensaje de error

	Pruebas para la función ejecutarEjemploRickYMorty
	√ debería manejar errores al obtener residentes
	√ debería manejar errores al obtener la ubicación
	√ debería ejecutar correctamente la función y mostrar los resultados

	Funciones de Orden Superior para Arrays

	ejecutarArrayFlatMap
		√ debería aplanar el array después de duplicar cada elemento

	ejecutarArrayFindIndex
		√ debería devolver el índice del primer elemento mayor a 10

	ejecutarArrayFind
		√ debería encontrar el primer elemento mayor a 10

	ejecutarArrayEvery
		√ debería verificar si todos los elementos son pares

	ejecutarArraySort
		√ debería ordenar el array de forma ascendente

	ejecutarArrayMap
		√ debería mapear el array y multiplicar cada elemento por 2

	ejecutarArraySome
		√ debería verificar si al menos un elemento es par

	ejecutarArrayFilter
		√ debería filtrar los elementos pares del array

	ejecutarArrayReduce
		√ debería reducir el array sumando sus elementos

	ejecutarForEach
		√ debería recorrer el array y mostrar los elementos con índices

Executed 16 of 16 specs SUCCESS in 0.216 sec.
Randomized with seed 66126.

> fundametos-de-desarrollo-web@1.0.0 test:jest
> jest

	PASS  test/jest/EjemploPOO.test.js (8.959 s)
	PASS  test/jest/utils.test.js (10.3 s)
	PASS  test/jest/Arrays.test.js (10.572 s)
----------------|---------|----------|---------|---------|-------------------
File            | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------------|---------|----------|---------|---------|-------------------
All files       |     100 |    91.66 |     100 |     100 |                   
   js           |     100 |    91.66 |     100 |     100 |                   
   Arrays.js    |     100 |     87.5 |     100 |     100 | 152               
   utils.js     |     100 |      100 |     100 |     100 |                   
   js/POO       |     100 |      100 |     100 |     100 | 
   EjemploPOO.js|     100 |      100 |     100 |     100 | 
----------------|---------|----------|---------|---------|-------------------

Test Suites: 3 passed, 3 total
Tests:       24 passed, 24 total
Snapshots:   0 total
Time:        14.58 s
Ran all test suites.</code></pre>
				</div>

			</section>
			<hr class="non-js">

		</main>
	</div>

	<footer class="footer" id="footer-javascript">
		<div>
			<p>&copy; 2024 Rickylobu. Todos los derechos reservados.</p>
			<!-- Sección de Redes Sociales -->
			<section class="social-media"> <a
					href="https://www.youtube.com/watch?v=NsQQnqn65Kg&list=PL0FBsi3fjGvDNgNQzXouUNfbpW326A3uj&ab_channel=RicardoL%C3%B3pezArriagaBueno"
					target="_blank"> <img src="https://www.svgrepo.com/show/13671/youtube.svg" alt="YouTube" width="30"
						height="30"> </a> <a
					href="https://www.youtube.com/watch?v=NsQQnqn65Kg&list=PL0FBsi3fjGvDNgNQzXouUNfbpW326A3uj&ab_channel=RicardoL%C3%B3pezArriagaBueno"
					target="_blank"> <img
						src="https://upload.wikimedia.org/wikipedia/commons/5/51/Facebook_f_logo_%282019%29.svg"
						alt="Facebook" width="30" height="30"> </a> <a
					href="https://www.youtube.com/watch?v=NsQQnqn65Kg&list=PL0FBsi3fjGvDNgNQzXouUNfbpW326A3uj&ab_channel=RicardoL%C3%B3pezArriagaBueno"
					target="_blank"> <img src="https://upload.wikimedia.org/wikipedia/commons/c/ce/X_logo_2023.svg"
						alt="Twitter" width="30" height="30"> </a> <a
					href="https://www.youtube.com/watch?v=NsQQnqn65Kg&list=PL0FBsi3fjGvDNgNQzXouUNfbpW326A3uj&ab_channel=RicardoL%C3%B3pezArriagaBueno"
					target="_blank"> <img src="https://upload.wikimedia.org/wikipedia/commons/a/a5/Instagram_icon.png"
						alt="Instagram" width="30" height="30"> </a> <a
					href="https://www.linkedin.com/in/ricardo-l%C3%B3pez-arriaga-bueno-210393159/" target="_blank">
					<img src="https://upload.wikimedia.org/wikipedia/commons/e/e9/Linkedin_icon.svg" alt="LinkedIn"
						width="30" height="30"> </a> <a href="https://github.com/rickylobu" target="_blank"> <img
						src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg" alt="GitHub"
						width="30" height="30"> </a> </section> <!-- Enlaces secundarios -->
			<nav class="secondary-links"> <a href="#">Política de Privacidad</a> <a href="#">Términos de
					Servicio</a> <a href="#">Contacto</a> </nav>
		</div>
	</footer>


	<!-- JavaScript se agrega al final del body
		debido a que es para que el .js interactue 
		con elementos del DOM ya renderizados -->
	<script src="js/VariablesPrimitivos.js"></script>

	<script src="js/Operadores.js"></script>

	<script src="js/EstructurasControl.js"></script>

	<script src="js/Funciones.js"></script>

	<script src="js/this.js"></script>

	<script src="js/Closure.js"></script>

	<script src="js/POO.js"></script>


	<!-- importación de módulo de Ejemeplo de POO en JavaScript -->
	<!-- Comentado porque esta en app.js
	<script type="module"> 
		import ejecutarEjemploPOO from './js/POO/EjemploPOO.js';
		document.querySelector('button[onclick="ejecutarEjemploPOO()"]').onclick = ejecutarEjemploPOO;
	</script>
	-->


	<!-- Cuando estás utilizando módulos ES (ECMAScript) en tu proyecto:
	 Los módulos ES requieren que el archivo JavaScript se cargue como 
	 un módulo para que las declaraciones import y export funcionen correctamente. 
	 
	 Módulos ES en el navegador: Los navegadores modernos soportan los módulos ES,
	 pero para que el navegador reconozca un archivo JavaScript como un módulo, debes
	 especificarlo usando el atributo <script type="module".> 
	 Esto le dice al navegador que el archivo debe ser tratado como un módulo ES,
	 permitiendo el uso de import y export.

	Importación de funciones: Cuando defines una función en un archivo de módulo ES
	 y la exportas, necesitas importarla en el archivo donde deseas usarla. 
	 Esto asegura que la función esté disponible en el contexto adecuado.

	Asignación de eventos: En este caso, asignamos la función ejecutarEjemploPOO 
	al evento onclick de un botón, debes importar la función y luego asignarla al evento.
	
	import ejecutarEjemploPOO from './js/POO/EjemploPOO.js';
	document.querySelector('button[onclick="ejecutarEjemploPOO()"]').onclick = ejecutarEjemploPOO;
	-->

	<!-- Considera que es type="module" debido a que utiliza otros archivos js como
		CargadorJSONenCode que se encarga de mostrar el código en su <code> correspondiente
			por medio de paths-js.json -->
	<script type="module" src="app.js"></script>


	<!-- Antes de Seguir con Asincronismo en JavaScript, utilizaremos 2 ejemplos sencillos -->
	<script src="js/EventLoopExplicacion.js"></script>


	<!-- Antes de Seguir con Asincronismo en JavaScript, el segundo ejemplo es de JSONPartido -->
	<script src="js/ejemploJSONPartido.js"></script>

	<script src="responsive.js"></script>
</body>

</html>